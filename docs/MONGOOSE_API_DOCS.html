<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FFFFFF"/>
  <link rel="canonical" href="https://mongoose.ws/documentation/" />

    <!-- HTML Meta Tags -->
  <meta name="description" content="Mongoose Embedded Networking and Web Server Library User Guide and API Reference. A quick start, a 2-minutes integration guide, build options, and much more." />
  <title>Mongoose :: Documentation</title>

  <!-- Facebook Meta Tags -->
  <meta property="og:url" content="https://mongoose.ws/documentation/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Mongoose :: Documentation">
  <meta property="og:description" content="Mongoose Embedded Networking and Web Server Library User Guide and API Reference. A quick start, a 2-minutes integration guide, build options, and much more.">
  <meta property="og:image" content="https://mongoose.ws/documentation/images/tutorials.svg">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="mongoose.ws">
  <meta property="twitter:url" content="https://mongoose.ws/documentation/">
  <meta name="twitter:title" content="Mongoose :: Documentation">
  <meta name="twitter:description" content="Mongoose Embedded Networking and Web Server Library User Guide and API Reference. A quick start, a 2-minutes integration guide, build options, and much more.">
  <meta name="twitter:image" content="https://mongoose.ws/documentation/images/tutorials.svg">
     
  <link rel="image_src" href="../documentation/images/tutorials.svg" />
  


  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="icon" href="/images/logo.svg?v=1" type="image/x-icon" />
<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">

<link href="/css/bootstrap.min.css" rel="stylesheet" />
<link href="/css/main.css" rel="stylesheet" />

<link rel="preload" href="/css/main.css" as="style" />
<link rel="/css/bootstrap.min.css" as="style" />

<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "name": "Mongoose Embedded Web Server for electronic devices",
        "image": "https://mongoose.ws/images/hero.svg"
    }
</script>

<link as="script" rel="prefetch" href="/js/bootstrap.min.js">
<script src="/js/bootstrap.min.js"></script>
<link as="script" rel="prefetch" href="/js/jquery.min.js">
<script src="/js/jquery.min.js"></script>

<!--
<link as="script" rel="prefetch" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js" async></script>
-->

<link as="script" rel="prefetch" href="/js/gdpr.js">
<script src="/js/gdpr.js" async></script>

<link as="script" rel="/js/github-snippet-loader.js">
<script src="/js/github-snippet-loader.js" async></script>
<script>
    var SendGoogleAnalyticsEvent = function(category) {
        window.gtag && window.gtag('event', 'custom', {
            event_category: category,
            event_label: '',
            value: 1,
        });
    };
</script>

  <script src="/js/prism.js"></script>
<link rel="stylesheet" href="/css/prism.css" />

<style>
  #docs { xfont-family: Verdana, Arial, sans-serif; xfont-size: 90%; }
  #sidebar a { display: block; text-decoration: none; font-weight: 600; transition: all 200ms; }
  #sidebar a:hover { background: #f5f5f5; }
  #sidebar a.highlight { background: #c8f1e2; border-radius: .2em; color: #222; }
  #sidebar .level-2 { padding-left: 1em; font-size: 90%;}
  #sidebar .level-3 { padding-left: 2.5em; font-size: 80%; }
  #sidebar .level-4 { padding-left: 3.5em; font-size: 75%; }
  #sidebar.hide-h1 .level-1 { display: none; }
  #sidebar .nav-link { margin-top: 1px !important; }

  #content h1, #content h2, #content h3, #content h4 { position: relative; color: #555; margin: 1.4em 0 13px 0px ; }
  #content h1:first-child {margin-top: 0;}
  #content table { min-width: 100%; margin: 1.5em auto; }
  #content table th, #content table td { border: 1px solid #ccc; padding: 0.5em 1em; }
  #content table th { background: #eee; }
  #content p { margin: 0.8em 0; }
  #content a { text-decoration: none; }
  #content a:hover { text-decoration: underline; }
  #content .h-link { color: #ddd; font-size: 32px; margin-left: 8px; text-decoration: none; }
  #content .h-link:hover { color: #bbb; }

  #content blockquote { padding-left: 2.5em; background: #c8f1e2; border: 1px solid #adc; border-radius: 0.5em; color: #555; }
  #content blockquote:before { margin-left: -1.5em; margin-top: 0.75em; content: '\261E'; position: absolute; }
  #content img { display: block; margin: 1em auto; max-width: 100%; }

  #xcontent summary > details > summary { margin-left: 1em; }

  .haskids .expander { margin-right: 0.2em; transition: all 0.3s; }
  .haskids.expanded .expander { transform: rotate(90deg);  }
  .ghcode pre { margin-top: 0px !important; }
  .w-33 { width: 33.33%; }
  .board-image { margin: 0 !important; }

  html { scroll-behavior: auto !important; }
</style>

<script src="/js/sidebar.js"></script>

  <script src="search.js"></script>
  <style>
  #search_results { width: 175%; position: absolute; margin: 0 auto; left: 0; border: 1px solid #ccc; z-index: 99; background: #fff; max-height: 50%; overflow-y: auto; overflow-x: hidden; }
  #search_results a { display: block; outline: none; text-decoration: none; transition: all 300ms ease-in-out; padding: 0 0.5em; }
  #search_results a:hover { color: #000; }
  #search_results a.selected { background: #eee; }
  </style>
</head>

<body>
  <div class="navbar navbar-expand-lg navbar-light p-1">
  <div class="container">
    <a class="navbar-brand" href="/">
      <img src="/images/logo.svg" height="40" width="40" alt="Mongoose Logo" class="my-auto" />
      <b class="d-inline-block ms-1 text-secondary my-auto">Mongoose</b>
    </a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#nb1" aria-controls="nb1" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="nb1">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0 justify-content-end flex-fill">
        <li class="nav-item dropdown">
          <a class="nav-link" href="#">Developers</a>
          <div class="dropdown-menu dropdown-menu-end dropdown-menu-right">
            <a class="dropdown-item" href="/wizard/"><table><tr><td><img src="/images/builder.svg" alt="web ui wizard"></td><td class="text-dark">Mongoose Wizard<div class="text-muted small">no-code Web UI builder</div></td></tr></table></a>
            <a class="dropdown-item d-none" href="/features/"><table><tr><td><img src="/images/features.svg" alt="features"></td><td class="text-dark">Overview<div class="text-muted small">feature list</div></td></tr></table></a>
            <a class="dropdown-item" href="/documentation/"><table><tr><td><img src="/images/docs.svg" alt="docs"></td><td class="text-dark">Documentation<div class="text-muted small">user guide and API reference</div></td></tr></table></a>
            <!-- <a class="dropdown-item" href="/reference-projects/"><table><tr><td><img src="/images/builder.svg" alt="web ui templates"></td><td class="text-dark">Reference Projects<div class="text-muted small">pre-built Web UI examples</div></td></tr></table></a>-->
            <a class="dropdown-item" href="/webinars/"><table><tr><td><img src="/images/webm.svg" alt="videos"></td><td class="text-dark">Videos and Webinars<div class="text-muted small">get in-depth expert insights</div></td></tr></table></a>
            <a class="dropdown-item" href="/articles/"><table><tr><td><img src="/images/case-study.svg" alt="articles"></td><td class="text-dark">Articles<div class="text-muted small">embedded technical articles</div></td></tr></table></a>
            <a class="dropdown-item" href="/comparison/"><table><tr><td><img src="/images/comparison.svg" alt="comparison"></td><td class="text-dark">Comparison<div class="text-muted small">comparison with other solutions</div></td></tr></table></a>
            <a class="dropdown-item" href="/security/"><table><tr><td><img src="/images/security.svg" alt="security"></td><td class="text-dark">Security<div class="text-muted small">security overview</div></td></tr></table></a>
            <a class="dropdown-item" href="/tls/"><table><tr><td><img src="/images/tls.svg" alt="TLS helper"></td><td class="text-dark">TLS Helper<div class="text-muted small">fetch CA certificates</div></td></tr></table></a>
            <a class="dropdown-item" href="https://github.com/cesanta/mongoose" target="_blank"><table><tr><td><img src="/images/github.svg" alt="github"></td><td class="text-dark">GitHub Repo<div class="text-muted small">get source code, file issues</div></td></tr></table></a>
            <a class="dropdown-item" href="https://github.com/cesanta/mongoose/discussions" target="_blank"><table><tr><td><img src="/images/chat.svg" alt="chat"></td><td class="text-dark">Community Forum<div class="text-muted small">ask questions, get answers</div></td></tr></table></a>
            <a class="dropdown-item" href="/binary/"><table><tr><td><img src="/images/desktop-app.svg" alt="binary"></td><td class="text-dark">Mongoose Binary<div class="text-muted small">pre-built executable</div></td></tr></table></a>
          </div>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link" href="#">Business</a>
          <div class="dropdown-menu dropdown-menu-end">
            <a class="dropdown-item" href="/case-studies/"><table><tr><td width="1"><img src="/images/case-study.svg" alt="case-study"></td><td class="text-dark">Case Studies<div class="text-muted small">customers successes</div></td></tr></table></a>
            <a class="dropdown-item" href="/testimonials/"><table><tr><td><img src="/images/testimonials.svg" alt="testimonials"></td><td class="text-dark">Testimonials<div class="text-muted small">customers feedback</div></td></tr></table></a>
            <a class="dropdown-item" href="/licensing/"><table><tr><td><img src="/images/licensing.svg" alt="licensing"></td><td class="text-dark">Licensing<div class="text-muted small">licensing information</div></td></tr></table></a>
            <a class="dropdown-item" href="/support/"><table><tr><td><img src="/images/support.svg" alt="support"></td><td class="text-dark">Support<div class="text-muted small">commercial support</div></td></tr></table></a>
            <a class="dropdown-item" href="/integration/"><table><tr><td><img src="/images/builder.svg" alt="builder"></td><td class="text-dark">Integration services<div class="text-muted small">custom development</div></td></tr></table></a>
            <a class="dropdown-item" href="/partners/"><table><tr><td width="1"><img src="/images/partners.svg" alt="partners"></td><td class="text-dark">Partners<div class="text-muted small">third party platforms</div></td></tr></table></a>
          </div>
        </li>
        <li class="nav-item"><a class="nav-link" href="/about/">About</a></li>
        <li class="nav-item"><a class="nav-link" href="/contact/">Contact</a></li>
      </ul>
    </div>
  </div>
</div>


  <div class="container">
    <ol class="breadcrumb">
      <li class="breadcrumb-item"><a href="/">Home</a></li>
      <li class="breadcrumb-item active" aria-current="page">Documentation</li>
    </ol>
  </div>

  <div class="container position-relative py-2" id="docs">
    <div class="row">
      <div class="col-md-4 col-lg-3 position-relative mb-5">
        <div class="sticky-top">
          <div class="py-2">
            <div class="position-relative">
              <input id="search_input" class="form-control form-control-sm d-inline-block" placeholder="search..."></input>
            </div>
            <div class="d-none" id="search_results"></div>
          </div>

          <div class="hide-native-scrollbar border-end"
               id="sidebar" style="max-height: 100vh; overflow-y:scroll;">
          </div>
        </div>
      </div>

      <div class="col-md-8 col-lg-9 mb-5" id="content">
        <h1 id="user-guide">User Guide</h1>
<h2 id="introduction">Introduction</h2>
<p>Mongoose is a networking library for C/C++. It implements event-driven,
non-blocking APIs for TCP, UDP, HTTP, WebSocket, MQTT.  It connects devices and
brings them online. Since 2004, a number of open source and commercial products
have utilized it. It even runs on the International Space Station! Mongoose
makes embedded network programming fast, robust, and easy.</p>
<p>Mongoose works on Windows, Linux, Mac, and on a many embedded architectures
such as STM32, NXP, TI, ESP32, and so on. It can run on top of the existing
OS and TCP/IP stack like FreeRTOS and lwIP, as well as on a bare metal,
utilising Mongoose&#39;s built-in TCP/IP stack and network drivers.</p>
<p>Want to evaluate Mongoose the easy way? Try <a href="/wizard/">Mongoose Wizard</a> - a no-code Web UI builder.</p>
<h2 id="2-minute-integration-guide">2-minute integration guide</h2>
<p><strong>Step 1.</strong> Follow <a href="tutorials/tools/">Build Tools</a> to setup your development
environment<br><strong>Step 2.</strong> Copy <a href="https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c">mongoose.c</a>
and <a href="https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h">mongoose.h</a>
to your source tree<br><strong>Step 3.</strong> Add the following snippets to your <code>main.c</code> file:</p>
<pre><code class="language-c">#include &quot;mongoose.h&quot;

// Connection event handler function
static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {  // New HTTP request received
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;  // Parsed HTTP request
    if (mg_match(hm-&gt;uri, mg_str(&quot;/api/hello&quot;), NULL)) {              // REST API call?
      mg_http_reply(c, 200, &quot;&quot;, &quot;{%m:%d}\n&quot;, MG_ESC(&quot;status&quot;), 1);    // Yes. Respond JSON
    } else {
      struct mg_http_serve_opts opts = {.root_dir = &quot;.&quot;};  // For all other URLs,
      mg_http_serve_dir(c, hm, &amp;opts);                     // Serve static files
    }
  }
}

int main() {
  struct mg_mgr mgr;  // Mongoose event manager. Holds all connections
  mg_mgr_init(&amp;mgr);  // Initialise event manager
  mg_http_listen(&amp;mgr, &quot;http://0.0.0.0:8000&quot;, fn, NULL);  // Setup listener
  for (;;) {
    mg_mgr_poll(&amp;mgr, 1000);  // Infinite event loop
  }
  return 0;
}
</code></pre>
<p><strong>Step 4.</strong> Rebuild and run. Point your browser at <a href="http://localhost:8000">http://localhost:8000</a>.</p>
<blockquote>
<p>NOTE: If you&#39;re building for some embedded system, create <code>mongoose_config.h</code>
and add extra build flags in that file. See <a href="#build-options">Build options</a> for details.</p>
</blockquote>
<h2 id="connections-and-event-manager">Connections and event manager</h2>
<p>Mongoose has two basic data structures:</p>
<ul>
<li><code>struct mg_mgr</code> - An event manager that holds all active connections</li>
<li><code>struct mg_connection</code> - A single connection descriptor</li>
</ul>
<p>Connections could be listening, outbound, or inbound. Outbound
connections are created by the <code>mg_connect()</code> call. Listening connections are
created by the <code>mg_listen()</code> call. Inbound connections are those accepted by a
listening connection. Each connection is described by a <code>struct mg_connection</code>
structure, which has a number of fields. All fields are exposed to the
application by design, to give an application full visibility into
Mongoose&#39;s internals.</p>
<p>Consider the snippet that starts an HTTP server:</p>
<pre><code class="language-c">  struct mg_mgr mgr;   // Event manager
  mg_mgr_init(&amp;mgr);   // Init manager
  mg_http_listen(&amp;mgr, &quot;http://0.0.0.0:8000&quot;, fn, NULL);   // Setup HTTP listener
  mg_http_listen(&amp;mgr, &quot;https://0.0.0.0:8443&quot;, fn, NULL);  // Setup HTTPS listener
  for (;;) {                  // Infinite event loop
    mg_mgr_poll(&amp;mgr, 1000);  // Process all connections
  }
</code></pre>
<p><code>mg_mgr_poll()</code> iterates over all connections, accepts new connections, sends and
receives data, closes connections, and calls event handler functions for the
respective events.</p>
<p>Each connection has two event handler functions: <code>c-&gt;fn</code> and <code>c-&gt;pfn</code>.  The
<code>c-&gt;fn</code> is a user-specified event handler function. The <code>c-&gt;pfn</code> is a
protocol-specific handler function that is set implicitly. For example, a
<code>mg_http_listen()</code> sets <code>c-&gt;pfn</code> to a Mongoose&#39;s HTTP event handler.  A
protocol-specific handler is called before a user-specific handler.  It parses
incoming data and may invoke protocol-specific events like <code>MG_EV_HTTP_MSG</code>.
In the snippet above, a user-specified <code>fn()</code> function will be called on
every event, like incoming HTTP request.</p>
<blockquote>
<p>NOTE: Since Mongoose&#39;s core is not protected against concurrent accesses,
make sure that all <code>mg_*</code> API functions are called from the same thread or
RTOS task.</p>
</blockquote>
<h2 id="send-and-receive-buffers">Send and receive buffers</h2>
<p>Each connection has a send and receive buffer:</p>
<ul>
<li><code>struct mg_connection::send</code> - Data to be sent to a peer</li>
<li><code>struct mg_connection::recv</code> - Data received from a peer</li>
</ul>
<p>When data arrives, Mongoose appends received data to the <code>recv</code> and triggers a
<code>MG_EV_READ</code> event. The user may send data back by calling one of the output
functions, like <code>mg_send()</code>, <code>mg_printf()</code> or a protocol-specific function like
<code>mg_ws_send</code>. Output functions append data to the <code>send</code> buffer.  When Mongoose
successfully writes data to the socket, it discards data from struct <code>mg_connection::send</code>
and sends an <code>MG_EV_WRITE</code> event.</p>
<h2 id="event-handler-function">Event handler function</h2>
<p>Each connection has an event handler function associated with it, which
must be implemented by the user. Event handler is the key element of
Mongoose, since it defines the connection&#39;s behavior. See below
for an example of an event handler function:</p>
<pre><code class="language-c">// Event handler function defines connection behavior
static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_READ) {
    mg_send(c, c-&gt;recv.buf, c-&gt;recv.len);   // Implement echo server
    c-&gt;recv.len = 0;                        // Delete received data
  }
}
</code></pre>
<ul>
<li><code>struct mg_connection *c</code> - The connection receiving this event</li>
<li><code>int ev</code> - An event number, defined in mongoose.h. For example, when data
arrives on an inbound connection, <code>ev</code> would be <code>MG_EV_READ</code></li>
<li><code>void *ev_data</code> - Points to the event-specific data, and it has a different
meaning for different events. For example, for an <code>MG_EV_READ</code> event,
<code>ev_data</code> is a <code>long *</code> pointing to the number of bytes received from a remote
peer and saved into the <code>c-&gt;recv</code> IO buffer. The exact meaning of <code>ev_data</code> is
described for each event. Protocol-specific events usually have <code>ev_data</code>
pointing to structures that hold protocol-specific information</li>
<li><code>c-&gt;fn_data</code>, <code>void *</code> - A user-defined pointer for the connection, which is a
placeholder for application-specific data. This <code>fn_data</code> pointer is set
during the <code>*_listen()</code> or <code>*_connect()</code> call. Listening connections copy the value of <code>c-&gt;fn_data</code> to the
newly accepted connection, so all accepted connections initially share the
same <code>fn_data</code> pointer. It is fine to update/replace that pointer for
any connection at any time by setting <code>c-&gt;fn_data = new_value;</code></li>
</ul>
<h2 id="events">Events</h2>
<p>Below is the list of events triggered by Mongoose, taken as-is from <code>mongoose.h</code>.
For each event, a comment describes the meaning of the <code>ev_data</code> pointer passed
to an event handler:</p>
<pre><code class="language-c">enum {
  MG_EV_ERROR,      // Error                        char *error_message
  MG_EV_OPEN,       // Connection created           NULL
  MG_EV_POLL,       // mg_mgr_poll iteration        uint64_t *uptime_millis
  MG_EV_RESOLVE,    // Host name is resolved        NULL
  MG_EV_CONNECT,    // Connection established       NULL
  MG_EV_ACCEPT,     // Connection accepted          NULL
  MG_EV_TLS_HS,     // TLS handshake succeeded      NULL
  MG_EV_READ,       // Data received from socket    long *bytes_read
  MG_EV_WRITE,      // Data written to socket       long *bytes_written
  MG_EV_CLOSE,      // Connection closed            NULL
  MG_EV_HTTP_HDRS,  // HTTP headers                 struct mg_http_message *
  MG_EV_HTTP_MSG,   // Full HTTP request/response   struct mg_http_message *
  MG_EV_WS_OPEN,    // Websocket handshake done     struct mg_http_message *
  MG_EV_WS_MSG,     // Websocket msg, text or bin   struct mg_ws_message *
  MG_EV_WS_CTL,     // Websocket control msg        struct mg_ws_message *
  MG_EV_MQTT_CMD,   // MQTT low-level command       struct mg_mqtt_message *
  MG_EV_MQTT_MSG,   // MQTT PUBLISH received        struct mg_mqtt_message *
  MG_EV_MQTT_OPEN,  // MQTT CONNACK received        int *connack_status_code
  MG_EV_SNTP_TIME,  // SNTP time received           uint64_t *epoch_millis
  MG_EV_WAKEUP,     // mg_wakeup() data received    struct mg_str *data
  MG_EV_USER        // Starting ID for user events
};
</code></pre>
<h2 id="connection-flags">Connection flags</h2>
<p><code>struct mg_connection</code> has a bitfield with connection flags.  Flags are binary:
they can be either 0 or 1.  Some flags are set by Mongoose and must be not
changed by an application code. For example, the <code>is_udp</code> flag tells the application if
that connection is UDP or not.  Some flags can be changed by application, for
example, the <code>is_draining</code> flag, if set by an application, tells Mongoose to send
the remaining data to a peer, and when everything is sent, close the connection.</p>
<blockquote>
<p>NOTE: User-changeable flags are: <code>is_hexdumping</code>, <code>is_draining</code>, <code>is_closing</code>.</p>
</blockquote>
<p>This is taken from <code>mongoose.h</code> as-is:</p>
<pre><code class="language-c">struct mg_connection {
  ...
  unsigned is_listening : 1;   // Listening connection
  unsigned is_client : 1;      // Outbound (client) connection
  unsigned is_accepted : 1;    // Accepted (server) connection
  unsigned is_resolving : 1;   // Non-blocking DNS resolv is in progress
  unsigned is_connecting : 1;  // Non-blocking connect is in progress
  unsigned is_tls : 1;         // TLS-enabled connection
  unsigned is_tls_hs : 1;      // TLS handshake is in progress
  unsigned is_udp : 1;         // UDP connection
  unsigned is_websocket : 1;   // WebSocket connection
  unsigned is_hexdumping : 1;  // Hexdump in/out traffic
  unsigned is_draining : 1;    // Send remaining data, then close and free
  unsigned is_closing : 1;     // Close and free the connection immediately
  unsigned is_full : 1;        // Stop reads, until cleared
  unsigned is_resp : 1;        // Response is still being generated
  unsigned is_readable : 1;    // Connection is ready to read
  unsigned is_writable : 1;    // Connection is ready to write
};
</code></pre>
<h2 id="opening-and-closing-connections">Opening and closing connections</h2>
<p>In order to open a listening (server) connection, call a corresponding
function for the respective protocol. For example, to open HTTP and
MQTT servers,</p>
<pre><code class="language-c">mg_http_listen(&amp;mgr, &quot;http://0.0.0.0:80&quot;, http_event_handler_fn, NULL);
mg_mqtt_listen(&amp;mgr, &quot;mqtt://0.0.0.0:1883&quot;, mqtt_event_handler_fn, NULL);
</code></pre>
<p>In order to open a listening connection for a custom protocol, use plain
TCP (or UDP if you wish) listener:</p>
<pre><code class="language-c">mg_listen(&amp;mgr, &quot;tcp://0.0.0.0:1234&quot;, tcp_event_handler_fn, NULL);
</code></pre>
<p>In order to open a client connection, use the <code>mg_*connect()</code> function for
the respective protocol:</p>
<ul>
<li><code>mg_connect()</code> for plain TCP/UDP or custom protocol</li>
<li><code>mg_http_connect()</code> for HTTP</li>
<li><code>mg_ws_connect()</code> for Websocket</li>
<li><code>mg_mqtt_connect()</code> for MQTT</li>
<li><code>mg_sntp_connect()</code> for SNTP</li>
</ul>
<p>Check out examples for SMTP client, SSDP client, and so on.</p>
<p>In order to close a connection, there is no dedicated function. You should tell
Mongoose to close the connection using connection flags. Inside your event
handler function, use one of these two flags:</p>
<ul>
<li><code>c-&gt;is_draining = 1;</code> - send all remaining data in the send buffer (&quot;drain&quot; the connection), then properly close the connection.</li>
<li><code>c-&gt;is_closing = 1;</code> - close straight away, remove the connection on the next poll cycle regardless of any buffered data or a clean TCP closure.</li>
</ul>
<p>For example, this simple TCP echo server closes the connection right after
echoing the first message back:</p>
<pre><code class="language-c">static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_READ) {
    mg_send(c, c-&gt;recv.buf, c-&gt;recv.len); // Send received data back
    c-&gt;recv.len = 0;     // Clean receive buffer
    c-&gt;is_draining = 1;  // Close this connection when the response is sent
  }
}
</code></pre>
<h2 id="best-practices">Best practices</h2>
<ul>
<li>Debug log. To increase debug verbosity, call <code>mg_log_set()</code>:<pre><code class="language-c">mg_log_set(MG_LL_DEBUG);
mg_mgr_init(&amp;mgr);
</code></pre>
The <code>MG_INFO()</code>, <code>MG_DEBUG()</code> logging macros use <code>putchar()</code> by default,
i.e. they use standard C <code>stdout</code> stream. That works fine on the traditional
OS. In the embedded environment, in order to see debug output, two ways
are possible: IO retargeting or Mongoose log redirection. IO retargeting
can already be implemented by an embedded SDK - for example ESP32 SDK
redirects <code>printf()</code> to the UART0. Otherwise, IO retargeting can be
implemented manually, see
<a href="https://github.com/cpq/bare-metal-programming-guide#redirect-printf-to-uart">guide</a>
for more details.
The alternative way is to redirect Mongoose logs:<pre><code class="language-c">void log_fn(char ch, void *param) {
  output_a_single_character_to_UART(ch);
}
...
mg_log_set_fn(log_fn, param);  // Use our custom log function
</code></pre>
</li>
<li>If you need to perform any sort of initialisation of your connection,
do it by catching <code>MG_EV_OPEN</code> event. That event is sent immediately
after a connection has been allocated and added to the event manager,
but before anything else:<pre><code class="language-c">static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_OPEN) {
    ... // Do your initialisation
  }
</code></pre>
</li>
<li>If you need to keep some connection-specific data, you have two options:<ul>
<li>Use the <code>c-&gt;fn_data</code> pointer. That pointer is passed to the event handler
as its last parameter:<pre><code class="language-c">static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_OPEN) {
    c-&gt;fn_data = malloc(123);       // Change our fn_data
  } else if (ev == MG_EV_CLOSE) {
    free(fn_data);  // Don&#39;t forget to free!
  }
  ...
}

// Every accepted connection inherits a NULL pointer as c-&gt;fn_data,
// but then we change it in its connection event handler to something else
mg_http_listen(&amp;mgr, &quot;http://localhost:1234&quot;, fn, NULL);
</code></pre>
</li>
<li>Use the <code>c-&gt;data</code> buffer, which can hold some amount of connection-specific data without extra memory allocation:<pre><code class="language-c">static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_WS_OPEN) {
    c-&gt;data[0] = &#39;W&#39;; // Established websocket connection, store something
    ...
</code></pre>
</li>
</ul>
</li>
<li>Use the <code>mg_http_reply()</code> function to create HTTP responses. That function
properly sets the <code>Content-Length</code> header, which is important. Of course
you can create responses manually, e.g. with <code>mg_printf()</code> function,
but be sure to set the <code>Content-Length</code> header:<pre><code class="language-c">mg_printf(c, &quot;HTTP/1.1 200 OK\r\Content-Length: %d\r\n\r\n%s&quot;, 2, &quot;hi&quot;);
</code></pre>
Alternatively, use chunked transfer encoding:<pre><code class="language-c">mg_printf(c, &quot;HTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n&quot;);
mg_http_printf_chunk(c, &quot;%s&quot;, &quot;foo&quot;);
mg_http_printf_chunk(c, &quot;%s&quot;, &quot;bar&quot;);
mg_http_printf_chunk(c, &quot;&quot;);  // Don&#39;t forget the last empty chunk
</code></pre>
<blockquote>
<p>NOTE: if you are not using
<code>mg_http_reply()</code> or <code>mg_http_*_chunk()</code>, make sure to set
<code>c-&gt;is_resp = 0;</code> when your event handler finished writing its response.</p>
</blockquote>
</li>
<li>Send and receive buffers, and the number of accepted connections, can grow indefinitely. If you need to keep a bound on them, you can do that in your respective event handlers:<pre><code class="language-c">static inline numconns(struct mg_mgr *mgr) {
  int n = 0;
  for (struct mg_connection *t = mgr-&gt;conns; t != NULL; t = t-&gt;next) n++;
  return n;
}

static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_ACCEPT) {
    if (numconns(c-&gt;mgr) &gt; LIMIT) {
      MG_ERROR((&quot;Too many connections&quot;));
      c-&gt;is_closing = 1;
    }
  } else if (ev == MG_EV_READ) {
    if (c-&gt;recv.len &gt; LIMIT) {
      MG_ERROR((&quot;Msg too large&quot;));
      c-&gt;is_draining = 1;
    }
  }
  ...
}
</code></pre>
<pre><code class="language-c">  if (c-&gt;send.len &gt; LIMIT) {
    MG_ERROR((&quot;Stalled&quot;));
  } else {
    // send
  }
</code></pre>
<ul>
<li>Mongoose uses this technique internally to shape traffic when serving large files; you don&#39;t need to do this unless you are dynamically sending data.</li>
</ul>
</li>
<li>On embedded environments, make sure the serving task has enough stack:
give it 2k for simple RESTful serving, or 4-8k for complex dynamic/static
serving. In certain environments, it is necessary to adjust heap size, too.
By default, IO buffer allocation size <code>MG_IO_SIZE</code> is 2048: change it to 512
to trim run-time per-connection memory consumption.<ul>
<li>If using TLS, the <code>MG_MAX_RECV_SIZE</code> limit must accomodate the largest record (16424 bytes), and the value of <code>MG_IO_SIZE</code> will affect decryption performance when receiving large content.</li>
</ul>
</li>
<li>On the other hand, in scenarios where data accumulates faster than it can be consumed, as for example, in TLS large file transfers, you might want to make <code>MG_IO_SIZE</code> larger to speed it up.</li>
</ul>
<h2 id="architecture-diagram">Architecture diagram</h2>
<img src="images/mongoose.svg" class="w-100" alt="Mongoose Architecture" />

<p>Mongoose Library can work on top of an existing TCP/IP stack - like on Windows,
Mac, Linux, Zephyr RTOS, Azure RTOS, lwIP, etc. Also it implements its own
TCP/IP stack with drivers - so in embedded environments, especially bare metal
ones, it can be used stand-alone and does not need any exta software to
implement networking.</p>
<p>Same goes with TLS. Mongoose can use 3rd party libraries like OpenSSL or mbedTLS,
but it also implements its own TLS 1.3 stack. Hence, Mongoose Library can be
a one-stop solution to provide the whole network functionality, including
secure communication over TLS.</p>
<h2 id="build-options">Build options</h2>
<p>Mongoose source code ships in two files:</p>
<ul>
<li><a href="https://github.com/cesanta/mongoose/blob/master/mongoose.h">mongoose.h</a> - API definitions</li>
<li><a href="https://github.com/cesanta/mongoose/blob/master/mongoose.c">mongoose.c</a> - Implementation</li>
</ul>
<p>Therefore, to integrate Mongoose into an application, simply copy these two
files to the application&#39;s source tree. The <code>mongoose.c</code> and <code>mongoose.h</code> files
are actually an amalgamation - non-amalgamated sources can be found at
<a href="https://github.com/cesanta/mongoose/tree/master/src">https://github.com/cesanta/mongoose/tree/master/src</a></p>
<p>Mongoose has 3 types of build constants (preprocessor definitions) that affect
the build: a target architecture/OS, target network stack, and tunables.  In
order to set the option during build time, use the <code>-D OPTION</code> compiler flag:</p>
<pre><code class="language-sh">$ cc app.c mongoose.c                           # Use defaults!
$ cc app.c mongoose.c -D MG_ENABLE_IPV6=1       # Build with IPv6 enabled
$ cc app.c mongoose.c -D MG_ARCH=MG_ARCH_RTX    # Set architecture
$ cc app.c mongoose.c -D MG_ENABLE_SSI=0 -D MG_IO_SIZE=8192  # Multiple options
</code></pre>
<table>
<thead>
<tr>
<th>Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>MG_ARCH</td>
<td>Autodetected</td>
<td>See <a href="https://github.com/cesanta/mongoose/blob/master/src/arch.h">arch.h</a></td>
</tr>
<tr>
<td>MG_TLS</td>
<td>MG_TLS_NONE</td>
<td>TLS implementation to use. Valid options:<br/> MG_TLS_NONE<br/>MG_TLS_BUILTIN<br/>MG_TLS_MBED<br/>MG_TLS_OPENSSL</td>
</tr>
<tr>
<td>MG_ENABLE_IPV6</td>
<td>0</td>
<td>Enable IPv6</td>
</tr>
<tr>
<td>MG_ENABLE_MD5</td>
<td>0</td>
<td>Use native MD5 implementation</td>
</tr>
<tr>
<td>MG_ENABLE_SSI</td>
<td>1</td>
<td>Enable serving SSI files by mg_http_serve_dir()</td>
</tr>
<tr>
<td>MG_ENABLE_CUSTOM_RANDOM</td>
<td>0</td>
<td>Provide custom RNG function mg_random()</td>
</tr>
<tr>
<td>MG_ENABLE_CUSTOM_TLS</td>
<td>0</td>
<td>Enable custom TLS library</td>
</tr>
<tr>
<td>MG_ENABLE_CUSTOM_MILLIS</td>
<td>0</td>
<td>Enable custom mg_millis() function</td>
</tr>
<tr>
<td>MG_ENABLE_POSIX_FS</td>
<td>Autodetected</td>
<td>Enable POSIX fopen/fread/.. functions. Valid options: 0 or 1</td>
</tr>
<tr>
<td>MG_ENABLE_PACKED_FS</td>
<td>0</td>
<td>Enable embedded FS support</td>
</tr>
<tr>
<td>MG_ENABLE_FATFS</td>
<td>0</td>
<td>Enable embedded FAT FS support</td>
</tr>
<tr>
<td>MG_ENABLE_LINES</td>
<td>undefined</td>
<td>If defined, show source file names in logs</td>
</tr>
<tr>
<td>MG_IO_SIZE</td>
<td>2048</td>
<td>Granularity of the send/recv IO buffer growth</td>
</tr>
<tr>
<td>MG_MAX_RECV_SIZE</td>
<td>(3 * 1024 * 1024)</td>
<td>Maximum recv buffer size</td>
</tr>
<tr>
<td>MG_MAX_HTTP_HEADERS</td>
<td>40</td>
<td>Maximum number of HTTP headers</td>
</tr>
<tr>
<td>MG_HTTP_INDEX</td>
<td>&quot;index.html&quot;</td>
<td>Index file for HTML directory</td>
</tr>
<tr>
<td>MG_FATFS_ROOT</td>
<td>&quot;/&quot;</td>
<td>FAT FS root directory</td>
</tr>
<tr>
<td>MG_ENABLE_SOCKET</td>
<td>1</td>
<td>Use BSD socket low-level API</td>
</tr>
<tr>
<td>MG_ENABLE_LWIP</td>
<td>0</td>
<td>lwIP network stack</td>
</tr>
<tr>
<td>MG_ENABLE_FREERTOS_TCP</td>
<td>0</td>
<td>Amazon FreeRTOS-Plus-TCP network stack</td>
</tr>
<tr>
<td>MG_ENABLE_RL</td>
<td>0</td>
<td>Keil MDK network stack</td>
</tr>
<tr>
<td>MG_ENABLE_TCPIP</td>
<td>0</td>
<td>Built-in Mongoose network stack</td>
</tr>
<tr>
<td>MG_ENABLE_TCPIP_PRINT_DEBUG_STATS</td>
<td>0</td>
<td>Print TCP/IP stats every second</td>
</tr>
<tr>
<td>MG_ENABLE_DRIVER_*</td>
<td>0</td>
<td>Enable specific driver. Available options:<br/>MG_ENABLE_DRIVER_STM32H<br/>MG_ENABLE_DRIVER_STM32F<br/>MG_ENABLE_DRIVER_IMXRT<br/>MG_ENABLE_DRIVER_CMSIS<br/>MG_ENABLE_DRIVER_RA<br/>MG_ENABLE_DRIVER_RW612<br/>MG_ENABLE_DRIVER_SAME54<br/>MG_ENABLE_DRIVER_MCXN<br/>MG_ENABLE_DRIVER_TM4C<br/>MG_ENABLE_DRIVER_TMS570<br/>MG_ENABLE_DRIVER_XMC7<br/>MG_ENABLE_DRIVER_XMC</td>
</tr>
</tbody></table>
<blockquote>
<p>NOTE: most build constants are defined in the
<a href="https://github.com/cesanta/mongoose/blob/master/src/config.h">src/config.h</a></p>
</blockquote>
<blockquote>
<p>NOTE: the <code>MG_IO_SIZE</code> constant also sets maximum UDP message size, see
<a href="https://github.com/cesanta/mongoose/issues/907">issues/907</a> for details. If
the application uses large UDP messages, increase the <code>MG_IO_SIZE</code> limit
accordingly.</p>
</blockquote>
<h2 id="custom-build">Custom build</h2>
<p>A custom build should be used for cases not covered by the
existing architecture options (e.g., an embedded architecture that
uses some proprietary RTOS and network stack).</p>
<p>In order to build on such systems, create a file called <code>mongoose_config.h</code>,
with defines and includes that are relevant to your platform, for example:</p>
<pre><code class="language-c">#include &lt;stdbool.h&gt;
#include &lt;stdarg.h&gt;

#define MG_ARCH MG_ARCH_CUSTOM
#define MG_ENABLE_POSIX_FS 0
#define MG_IO_SIZE 256
</code></pre>
<h2 id="using-json">Using JSON</h2>
<p>Mongoose Library is often used to implement RESTful services, which use JSON
format for data exchange. Therefore Mongoose provides functions to <a href="#json">parse JSON
strings</a> and <a href="#mg_snprintf-mg_vsnprintf">create JSON strings</a> easily.</p>
<p>For example, the following event handler function handles a POST request
to the <code>/api/sum</code> URI. The POST body is expected to be a JSON array of two
numbers, like <code>[123.38, -2.72]</code>. Here is an example <code>curl</code> command that
generates such request:</p>
<pre><code class="language-sh">curl localhost:8000/api/sum -d &#39;[123.38, -2.72]&#39;
</code></pre>
<p>The handler returns the sum of those two numbers. The <code>mg_json_get_num()</code>
function is used to extract values from the JSON string, and <code>mg_http_reply()</code>
prints a JSON string back:</p>
<pre><code class="language-c">static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    if (mg_match(hm-&gt;uri, mg_str(&quot;/api/sum&quot;), NULL)) {
      double num1 = 0.0, num2 = 0.0;
      mg_json_get_num(hm-&gt;body, &quot;$[0]&quot;, &amp;num1);  // Extract first number
      mg_json_get_num(hm-&gt;body, &quot;$[1]&quot;, &amp;num2);  // Extract second number
      mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;,
                    &quot;{%m:%g}\n&quot;, MG_ESC(&quot;result&quot;), num1 + num2);
    } else {
      ...
    }
  }
</code></pre>
<p>There is also a set of functions to ease server-side processing by means of
<a href="#rpc">RPC</a> methods.</p>
<p>The following tutorials have working usage examples:</p>
<ul>
<li><a href="tutorials/webui/webui-rest/">REST basics</a></li>
<li><a href="tutorials/websocket/websocket-server/">Websocket server</a></li>
<li><a href="tutorials/websocket/websocket-client/">Websocket client</a></li>
<li><a href="tutorials/websocket/json-rpc-over-websocket/">JSON-RPC over WS</a></li>
<li><a href="tutorials/webui/webui-plain/">Pure JavaScript UI</a></li>
<li><a href="tutorials/webui/webui-push/">Data push</a></li>
</ul>
<h2 id="built-in-tcpip-stack">Built-in TCP/IP stack</h2>
<p>Mongoose works on any system that provides BSD socket API. In other words,
it works on top of any BSD-compatible TCP/IP stack. That includes UNIX, Mac,
Windows systems, as well as some embedded TCP/IP stacks like lwIP.
However, Mongoose provides its own TCP/IP stack that can be activated by
the build option <code>MG_ENABLE_TCPIP</code> set to <code>1</code>. It can be done either
by setting compiler flags or via <code>mongoose_config.h</code>:</p>
<ul>
<li>Via the compiler flags (e.g.: gcc): add <code>-D MG_ENABLE_TCPIP=1</code> to the build flags</li>
<li>Via <code>mongoose_config.h</code>: add the following line:<pre><code class="language-c">#define MG_ENABLE_TCPIP 1           // Enable built-in TCP/IP stack
</code></pre>
</li>
</ul>
<p>Mongoose&#39;s TCP/IP stack provides a 
<a href="https://github.com/cesanta/mongoose/blob/90a23fe/src/net_builtin.h#L10-L15">driver API</a>
that makes it easy to create a driver. There is a bunch of built-in drivers
available, for example STM32 F2/F4/F7, STM32 H5/H7, SAME54, TM4C, W5500. You
can take a look at their implementation in the <a href="https://github.com/cesanta/mongoose/tree/master/src/drivers">src/drivers/</a>
directory. Every driver gets activated by its respective build option, for example the
STM32H5 driver needs <code>MG_ENABLE_DRIVER_STM32H</code> set to <code>1</code>:</p>
<ul>
<li><p>Via the compiler flags: add <code>-DMG_ENABLE_DRIVER_STM32H=1</code> to the build flags</p>
</li>
<li><p>Via <code>mongoose_config.h</code>: add the following line:</p>
<pre><code class="language-c">#define MG_ENABLE_DRIVER_STM32H 1   // Enable STM32H network driver
</code></pre>
</li>
<li><p>For more information on how to develop your own driver, follow the <a href="tutorials/cmsis_driver">CMSIS-Driver tutorial</a></p>
</li>
</ul>
<p>In addition to this, <a href="#mongoose-wizard">Mongoose Wizard</a> generates code for several standard boards.</p>
<ul>
<li>For more information on how to configure Mongoose for your own board, follow the <a href="tutorials/hardware/">Hardware tutorial</a></li>
</ul>
<h2 id="built-in-tls13-stack">Built-in TLS1.3 stack</h2>
<p>Mongoose implements a built-in TLS 1.3 stack. It can be enabled by one of the
following ways:</p>
<ul>
<li>Via the compiler flags: add <code>-DMG_TLS=MG_TLS_BUILTIN</code> to the build flags</li>
<li>Via <code>mongoose_config.h</code>: add the following line:<pre><code class="language-c">#define MG_TLS MG_TLS_BUILTIN  // Enable built-in TLS 1.3 stack
</code></pre>
</li>
</ul>
<h2 id="built-in-ota-firmware-updates">Built-in OTA firmware updates</h2>
<p>Along with networking functionality - Web UI, remote control, etc, developers
need to develop Over-the-Air firmware updates. Thus Mongoose provides a
built-in API for firmware updates. It is simple and can be inspected at
<a href="https://github.com/cesanta/mongoose/blob/master/src/ota.h">src/ota.h</a> file.</p>
<p>The default <a href="https://github.com/cesanta/mongoose/tree/master/tutorials/http/device-dashboard/">device dashboard example</a>
implements an example Web UI for firmware updates, which can be used as a
skeleton for production implementation. You can take a look at the UI online
at <a href="https://mongoose.ws/device-dashboard/">https://mongoose.ws/device-dashboard/</a> - login as admin/admin and click
on the &quot;Firmware Updates&quot; sidebar link. It is going to look like this:</p>
<img src="../webinars/ota.webp" alt="Web UI for OTA firmware update"/>

<p>In essence, the update process requires 3 functions: <code>ota_begin()</code>, <code>ota_write()</code>, and <code>ota_end()</code>.
The implementation is driven by the build option <code>MG_OTA</code>. By default it is
set to <code>#define MG_OTA MG_OTA_NONE</code>, which activates <a href="https://github.com/cesanta/mongoose/blob/master/src/ota_dummy.c">src/ota_dummy.c</a>, 
a stub implementation that does nothing. By setting <code>#define MG_OTA MG_OTA_CUSTOM</code>
in <code>mongoose_config.h</code> you can create your own set of <code>mg_ota_*</code> functions.</p>
<p>Devices with internal flash can set <code>#define MG_OTA MG_OTA_FLASH</code>, which requires the <code>mg_flash_*</code> API from <a href="https://github.com/cesanta/mongoose/blob/master/src/device.h">src/device.h</a>.</p>
<p>Those functions implement the <code>mg_flash_*</code> API, including <code>mg_flash_load()</code> and <code>mg_flash_save()</code>. These are utility functions to load/save arbitrary data persistently in the last sector of the flash without a filesystem. See the
<a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/nucleo-h563zi-make-baremetal-builtin/">Nucleo-H563 baremetal example</a>
with the device Web UI dashboard, firmware updates, and persistent storage of device configuration on flash. Note: the screenshot above
was taken from that example.</p>
<p>For more information on using this feature, follow the <a href="tutorials/firmware-update/">Firmware Update tutorial</a></p>
<h1 id="reference-projects">Reference projects</h1>
<p>Mongoose Library provides several reference projects - &quot;complete&quot; projects that can be used as a base for a production firmware.</p>
<h2 id="web-ui-dashboard">Web UI dashboard</h2>
<p>See the <a href="/documentation/tutorials/device-dashboard/">Web UI dashboard guide</a> </p>
<h2 id="iot-fleet-management">IoT fleet management</h2>
<p>See the <a href="/documentation/tutorials/mqtt-dashboard/">IoT fleet management guide</a> </p>
<h1 id="mongoose-wizard">Mongoose Wizard</h1>
<p>Mongoose Wizard is a no-code visual tool for creating connected applications on
embedded devices. Mongoose Wizard generates ready-to-go projects for a variety
of microcontrollers, as well as for Windows/Mac/Linux, which makes it very
easy to develop/iterate/test. You can start using Mongoose Wizard immediately at
<a href="https://mongoose.ws/wizard/">https://mongoose.ws/wizard/</a>.</p>
<p>We recommend to watch video tutorials from this YouTube playlist:
<a href="https://www.youtube.com/watch?v=vJF5repAxXY&list=PL_hLobTQiQqD_uLh6H55KfZbtJkiuWvkF">Mongoose Wizard Tutorials</a></p>
<h2 id="mongoose-wizard-concept">Mongoose Wizard Concept</h2>
<p>The core concept of Mongoose Wizard is the JSON configuration file, which
describes your application options, target hardware / software, Web UI,
and RESTful API.</p>
<p>Mongoose Wizard&#39;s frontend is a visual way of editing configuration file.
Alternatively, it can be edited manually using your favorite editor.</p>
<p>Mongoose Wizard&#39;s backend takes a configuration file as an input, and
generates a ready-to-go project as an output.
You can download that project to your workstation and build/flash/run it.
Alternatively, if you&#39;re using Chrome browser (which provides Web USB support),
you can build and flash generated project directly from a browswer.</p>
<p>The network functionality is generated using Mongoose Library, and interfaces
with the rest of the firmware via a set of &quot;glue&quot; functions and structures.
The glue API is consolidated in the <code>mongoose_glue.{c,h}</code> files, and is meant
to be modified by the user to &quot;glue&quot; the generated functionality to the
hardware.</p>
<p>For example, a Web UI can show a panel with a toggle button, and the generated
glue code is:</p>
<ul>
<li>a structure with a boolean value</li>
<li>a getter and setter functions for that structure</li>
</ul>
<p>Generated in <code>mongoose_glue.h</code>:</p>
<pre><code class="language-c">struct leds {
  bool led1;
};
</code></pre>
<p>Generated in <code>mongoose_glue.c</code>:</p>
<pre><code class="language-c">// Generated default code maps Web UI toggle button to the structure
struct leds s_leds = {false};

void glue_get_leds(struct leds *leds) {
  // Insert your code here to sync s_leds to your hardware
  *leds = s_leds;
}
void glue_set_leds(struct leds *leds) {
  s_leds = *leds;
  // Insert your code here to sync s_leds to your hardware
}
</code></pre>
<h2 id="overriding-default-glue-callbacks">Overriding default glue callbacks</h2>
<p>In order to glue that implementation to the hardware, a getter and setter
function should be modified to &quot;synchronise&quot; the hardware to the structure.
This is done by following steps:</p>
<ol>
<li>Create getter and setter functions with the same signature as the default
ones but with the different name - for example, change <code>glue_</code> prefix to <code>my_</code>:</li>
</ol>
<pre><code class="language-c">void my_get_leds(struct leds *leds) {
  leds-&gt;led1 = gpio_read(LED1);  // Read hardware, populate structure
}
void my_set_leds(struct leds *leds) {
  gpio_write(LED1, leds-&gt;led1); // Read structure, sync to hardware
}
</code></pre>
<ol start="2">
<li>Substitute the default glue callbacks with your custom ones by calling
<code>mongoose_set_http_handlers()</code> after <code>mongoose_init()</code>:</li>
</ol>
<pre><code class="language-c">mongoose_init();
mongoose_set_http_handlers(&quot;leds&quot;, my_get_leds, my_set_leds);  // &lt;-- Add this
for (;;) {
  mongoose_poll();
}
</code></pre>
<p>Different REST API endpoint types generate use different callbacks. The list
below contains the summary:</p>
<pre><code class="language-c">mongoose_set_http_handlers(&quot;data&quot;, my_get_XXX, my_set_XXX);
mongoose_set_http_handlers(&quot;action&quot;, my_check_XXX, my_start_XXX);
mongoose_set_http_handlers(&quot;upload&quot;, my_open_XXX, my_close_XXX, my_write_XXX);
mongoose_set_http_handlers(&quot;ota&quot;, my_open_XXX, my_close_XXX, my_write_XXX);
mongoose_set_http_handlers(&quot;custom&quot;, my_reply_XXX);
</code></pre>
<p>Similarly, callback for other protocols can be overridden too. Here is the
relevant API:</p>
<pre><code class="language-c">struct mongoose_mqtt_handlers {
  struct mg_connection *(*connect_fn)(mg_event_handler_t);
  void (*tls_init_fn)(struct mg_connection *);
  void (*on_connect_fn)(struct mg_connection *, int);
  void (*on_message_fn)(struct mg_connection *, struct mg_str, struct mg_str);
  void (*on_cmd_fn)(struct mg_connection *, struct mg_mqtt_message *);
};
void mongoose_set_mqtt_handlers(struct mongoose_mqtt_handlers *);

struct mongoose_modbus_handlers {
  bool (*read_reg_fn)(uint16_t address, uint16_t *value);
  bool (*write_reg_fn)(uint16_t address, uint16_t value);
};
void mongoose_set_modbus_handlers(struct mongoose_modbus_handlers *);

void mongoose_set_sntp_handler(void (*fn)(uint64_t epoch_ms));

void mongoose_set_auth_handler(int (*fn)(const char *user, const char *pass));
</code></pre>
<h2 id="configuration-file-format">Configuration file format</h2>
<p>Configuration file has several sections, annotated below:</p>
<pre><code class="language-js">{
  &quot;version&quot;: &quot;1.0.1&quot;,   // format version
  &quot;api&quot;:     { ... },   // RESTful API definitions
  &quot;ui&quot;:      { ... },   // Web UI controls
  &quot;http&quot;:    { ... },   // HTTP protocol support
  &quot;mqtt&quot;:    { ... },   // MQTT protocol support
  &quot;dns&quot;:     { ... },   // DNS/MDNS protocol support
  &quot;sntp&quot;:    { ... },   // SNTP (network time sync) protocol support
  &quot;modbus&quot;:  { ... },   // Modbus-TCP protocol support
  &quot;build&quot;:   { ... }    // Target hardware, IDE, OS
}
</code></pre>
<h2 id="rest-api">REST API</h2>
<p>Below is the annotated REST API snippet from the configuration file:</p>
<pre><code class="language-js">&quot;api&quot;: {                 // RESTful API endpoints. 4 types: data, array, action, upload, ota
  &quot;reboot&quot;: {
    &quot;type&quot;: &quot;action&quot;,    // An action endpoint maps to a button. A button click triggers an action
    &quot;read_level&quot;: 3,     // Read access level
    &quot;write_level&quot;: 7,    // Write access level
    &quot;value&quot;: false       // Default action value - false (not triggered)
  },
  &quot;firmware_update&quot;: {
    &quot;type&quot;: &quot;ota&quot;,       // A firmware update endpoint - maps to a button that trigger file upload
    &quot;read_level&quot;: 3,     // Read access level
    &quot;write_level&quot;: 7     // Write access level
  },
  &quot;file_upload&quot;: {
    &quot;type&quot;: &quot;upload&quot;,    // A file upload endpoint - maps to a button that trigger file upload
    &quot;read_level&quot;: 3,     // Read access level
    &quot;write_level&quot;: 7     // Write access level
  },
  &quot;state&quot;: {             // struct state will be generated in the glue code
    &quot;type&quot;: &quot;data&quot;,      // Data endpoint maps to a Web UI panel, and a C structure
    &quot;readonly&quot;: true,    // Optional attribute that prevents generation of the setter function
    &quot;read_level&quot;: 3,     // Read access level
    &quot;attributes&quot;: {      // Structure attributes
      &quot;speed&quot;: { &quot;type&quot;: &quot;int&quot;, &quot;value&quot;: 42},  // Integer and its default value
      &quot;humidity&quot;: { &quot;type&quot;: &quot;double&quot;, &quot;format&quot;: &quot;%.4f&quot;, &quot;value&quot;: 12.34}, // Double, its format and its default value
      &quot;version&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;size&quot;: 20, &quot;value&quot;: &quot;1.0.0&quot;},     // String, its size and its default value
      &quot;online&quot;: { &quot;type&quot;: &quot;bool&quot;, &quot;value&quot;: true}    // A Boolean and its default value
    }
  },
  &quot;graph_data&quot;: {
    &quot;type&quot;: &quot;custom&quot;,    // Graph endpoint, returns timeseries
    &quot;read_level&quot;: 3,     // Read access level
    &quot;write_level&quot;: 7     // Write access level
    &quot;value&quot;: [           // Timeseries data: timestamp + value pairs
      [1724576787, 20.3],
      [1724576847, 27.2]
    ]
  }
},
</code></pre>
<h2 id="web-ui">Web UI</h2>
<p>If Web UI is enabled in the http settings (<code>http.ui</code> set to <code>true</code>), then
the <code>ui</code> section of the configuration describes the UI dashboard that will
be rendered.</p>
<pre><code class="language-js">&quot;ui&quot;: {
  &quot;brand&quot;:  &quot;My Brand&quot;,    // Brand name - shown on login and sidebar
  &quot;logo&quot;:   &quot;...&quot;,         // A string with SVG logo
  &quot;buttons&quot;: &quot;metal&quot;,      // Buttons/toggle buttons color
  &quot;pages&quot;: [             // Describes UI pages. Each page is mapped on a sidebar
    {
      &quot;title&quot;: &quot;Dashboard&quot;,  // Page title
      &quot;icon&quot;: &quot;desktop&quot;,     // Page icon
      &quot;level&quot;: 0,            // Access level
      &quot;classes&quot;: &quot;page&quot;,     // CSS classes (optional)
      &quot;css&quot;: &quot;&quot;,             // Inline CSS styles (optional)
      &quot;layout&quot;: [ ... ]      // Child elements (optional)
    }
  ]
},
</code></pre>
<p>The &quot;layout&quot; attribute for pages describe UI elements, which could be nested.
Here&#39;s the format for the UI element:</p>
<pre><code class="language-js">{
  &quot;type&quot;: &quot;&quot;,             // Optional. Can be &quot;toggle&quot;, &quot;action&quot;, &quot;dropdown&quot;, &quot;input&quot;, &quot;upload&quot;, &quot;ota&quot;. If absent, generates &quot;div&quot; element
  &quot;format&quot;: &quot;hi!&quot;,        // Optional. Static text / HTML code. Can contain references to API data: &quot;Current temperature: ${state.temperature}&quot;
  &quot;classes&quot;: &quot;flex&quot;,      // Optional. CSS classes
  &quot;css&quot;: &quot;color: red;&quot;,   // Optional. Inline CSS styles
  &quot;layout&quot;: [ ... ]       // Optional. Nested elements
}
</code></pre>
<h2 id="element-types">Element types</h2>
<p>Note: all elements can have <code>classes</code> and <code>css</code> attributes.</p>
<p>Container. Use <code>flex</code> class for horizonal, <code>flex flex-col</code>
for vertical flex. The most common issue is to set the width of the child
elements - for example, panels, or titles. Here is the quick guide:</p>
<ul>
<li>To set a fixed width, use <code>&quot;css&quot;: &quot;flex: 0 0 10em;&quot;</code> or <code>&quot;css&quot;: &quot;flex: 0 0 20%;&quot;</code></li>
<li>To set an equal width, use <code>&quot;classes&quot;: &quot;flex-1&quot;</code></li>
<li>Otherwise, an item will be sized to accomodate its content</li>
</ul>
<pre><code class="language-js">{ &quot;classes&quot;: &quot;flex&quot;, &quot;layout&quot;: []}
</code></pre>
<p>Text / label</p>
<pre><code class="language-js">{ &quot;format&quot;: &quot;hi!&quot;, &quot;classes&quot;: &quot;text-sm font-bold&quot;, &quot;css&quot;: &quot;color: red;&quot; }
</code></pre>
<blockquote>
<p>Text can include HTML markup, and also special notation <code>${OBJECT.ATTRIBUTE}</code>,
which substitutes by the respective API value. For example:
<code>Current temperature: &lt;b&gt;${state.temperature}&lt;/b&gt;</code></p>
</blockquote>
<p>Input</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;input&quot;,  &quot;ref&quot;: &quot;OBJECT_API.ATTRIBUTE&quot; }
</code></pre>
<p>Toggle</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;toggle&quot;,  &quot;ref&quot;: &quot;OBJECT_API.ATTRIBUTE&quot; }
</code></pre>
<p>Dropdown</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;dropdwon&quot;,  &quot;ref&quot;: &quot;OBJECT_API.ATTRIBUTE&quot;, &quot;options&quot;: &quot;aa,bb,cc&quot; }
</code></pre>
<p>Status (green or red circle)</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;status&quot;,  &quot;ref&quot;: &quot;OBJECT_API.ATTRIBUTE&quot; }
</code></pre>
<p>File Upload</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;updload&quot;,  &quot;ref&quot;: &quot;UPLOAD_API_NAME&quot; }
</code></pre>
<p>OTA (firmware update)</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;ota&quot;,  &quot;ref&quot;: &quot;OTA_API_NAME&quot; }
</code></pre>
<p>Action (rendered as a pushbutton, triggers an action on click)</p>
<pre><code class="language-js">{ &quot;type&quot;: &quot;action&quot;,  &quot;ref&quot;: &quot;ACTION_API_NAME&quot; }
</code></pre>
<h2 id="expressions">Expressions</h2>
<p>Element&#39;s attributes can have embedded Javascript expressions inside.
For example, element&#39;s <code>css</code> attribute, which translates to the HTML <code>style</code>,
can be a simple text like <code>color: red;</code>, but can also contain expressions.</p>
<p>Javascript expressions are specified inside the curly brackets prepended
by the dollar sign: <code>${...}</code>. Expressions can be conditional, which allows
to alter any element depending on the value of the REST API.
For example, this alters the background of element:</p>
<pre><code>&quot;css&quot;: &quot;color: cyan; background: ${state.online ? &#39;green&#39;: &#39;red&#39;};&quot;
</code></pre>
<h2 id="attributes">Attributes</h2>
<p>Below is the list of valid attributes that any element can have:</p>
<ul>
<li><code>classes</code> - (any element) a string, space separated list of CSS classes, e.g.</li>
<li><code>css</code> - (any element)  a string, semicolon-separated list of CSS rules</li>
<li><code>disabled</code> - (input, toggle, dropdown) a boolean, either <code>true</code> or <code>false</code></li>
<li><code>min,max</code> - (gauge, progress) a number</li>
<li><code>min,max,step</code> - (number input) a number</li>
<li><code>readonly</code> - (input) a boolean, either <code>true</code> or <code>false</code></li>
</ul>
<p>In the Wizard UI, those can be set in the &quot;Extra&quot; field,
which should be a valid JSON object that one or more of the above keys.</p>
<h2 id="api-access-levels">API access levels</h2>
<p>Each entry in the <code>ui.api</code> generates a RESTful endpoint <code>/api/ENTRY_NAME</code>.
An entry can be given a read and write access level. When a user logs in to
the UI, a user is given an access level, so the API&#39;s read and write level
can restrict who&#39;s able to read and write to the given API.</p>
<p>For example, a default dashboard project defines two users, &quot;user&quot; with
access level 3 and &quot;admin&quot; with access level 7. A &quot;leds&quot; API endpoint
allows &quot;user&quot; to read <code>/api/leds</code>, but not modify it. &quot;admin&quot; can both
read and write to it:</p>
<pre><code class="language-sh">$ curl -u admin:admin DEVICE_IP/api/leds
{&quot;led1&quot;: false, &quot;led2&quot;: false}
$ curl -u admin:admin DEVICE_IP/api/leds -d &#39;{&quot;led2&quot;: true}&#39;
{&quot;led1&quot;: false, &quot;led2&quot;: true}
$ curl -u user:user DEVICE_IP/api/leds -d &#39;{&quot;led2&quot;: true}&#39;
Forbidden
</code></pre>
<h2 id="web-ui-login">Web UI login</h2>
<p>If Web UI login is activated on a settings page, then Wizard enables
granular access control to pages, panels, and variables in the following way:</p>
<ol>
<li>Every user has an associated access level, visible to both UI and the device.
A User - defined <code>glue_authenticate()</code> function
assigns group ID to the users. An access level is an integer from 1 to 9</li>
<li>Access levels are hierarchical: the higher the level, the more privileged it is
User group 9 is the most privileged. Level 1 is the least privileged</li>
<li>Access level 0 means that a privilege access check is disabled, and anyone can access that API</li>
</ol>
<h2 id="http-protocol-support">HTTP protocol support</h2>
<pre><code class="language-js">&quot;http&quot;: {
  &quot;http&quot;: true,      // Enable/disable HTTP server
  &quot;https&quot;: false,    // Enable/disable HTTPS (secure) server
  &quot;ui&quot;: true,        // Generate Web UI
  &quot;login&quot;: true      // Enable/disable user login for the Web UI
},
</code></pre>
<h2 id="execute-functions-after-a-delay">Execute functions after a delay</h2>
<p>Sometimes a certain function needs to be executed after a delay. For example,
device must be rebooted after a configuration change. In order to execute
such function after some delay, Mongoose API function <code>mg_timer_add()</code> can
be used:</p>
<pre><code class="language-c">mg_timer_add(&amp;g_mgr, 500, 0,  my_func, NULL);  // Run my_func after 500 ms delay
</code></pre>
<h2 id="autoupdate-interval">Autoupdate interval</h2>
<p>The <code>ui.heartbeat</code> setting is an integer value, which is an interval in
seconds for the Web UI to auto-refresh. If that value is <code>0</code>, then auto-refresh
is disabled. Otherwise, Web UI makes an <code>/api/heartbeat</code> API call every
<code>ui.heartbeat</code> seconds.</p>
<p>The <code>/api/heartbeat</code> API call returns a number, which in an internal version
count. If that version count changes (increments), then Web UI re-fetches
all API values, and refreshes the UI. That is, in order to automatically
update UI elements, that internal counter should change. That internal counter
is incremented by the <code>glue_update_state()</code> function.</p>
<p>The internal version counter is automatically incremented every time
a <code>glue_set_*</code> function is called - in other words, if someone clicks on the
save button.</p>
<p>If API value is changed somewhere else in the firmware code, the UI must be
notified about this change by calling <code>glue_update_state()</code> function.</p>
<blockquote>
<p>Call <code>glue_update_state()</code> in your firmware to force UI refresh. Note
that refreshing UI is expensive, so call <code>glue_update_state()</code> only if
any of the API variable values really changes.</p>
</blockquote>
<p>Also, that periodic poll updates a toolbar indicator, that
shows device connection status. Normally it is green:
<img alt="Successful heartbeat indicator" src="images/heartbeat-ok.png" class="w-75 border" /></p>
<p>If a device misses hearbeats, it becomes red:
<img alt="Successful heartbeat indicator" src="images/heartbeat-fail.png" class="w-75 border" /></p>
<p>In other words, auto-refresh ensures that you&#39;re looking at the Web UI that is
not stale.</p>
<h2 id="websockets-updates">Websockets updates</h2>
<p>If Websocket support is enabled in the HTTP settings, then device can send
frequent periodic updates to all connected Web UI clients. A Websocket message
is constructed by the user and looks like this:</p>
<pre><code class="language-json">{&quot;key1&quot;: value1, &quot;key2&quot;: value2, ...}
</code></pre>
<p>When a Websocket message is received by the UI, it&#39;s values get integrated
into the synthetic API variable called <code>websocket</code>. In other words, the following
API variable gets created and updated:</p>
<pre><code class="language-json">{
  &quot;websocket&quot;: {
    &quot;key1&quot;: value1,
    &quot;key2&quot;: value2
  }
}
</code></pre>
<p>On the Web UI side, it is possible to bind UI elements to such variable.
For example, a text element can be <code>Hello, the current voltage is ${websocket.key1}</code>.
Note that the websocket API is read-only.</p>
<p>On the device side, it is possible to add one or more websocket callbacks,
for different intervals. In the example below, two callbacks are added
with the interval of 50 ms and 250 ms:</p>
<pre><code class="language-c">#include &quot;mongoose_glue.h&quot;

static void ws_200(struct mg_connection *c) {
  mg_ws_printf(c, WEBSOCKET_OP_TEXT, &quot;{%m: %llu}&quot;, MG_ESC(&quot;time&quot;), mg_now());
}

static void ws_500(struct mg_connection *c) {
  mg_ws_printf(c, WEBSOCKET_OP_TEXT, &quot;{%m: %d}&quot;, MG_ESC(&quot;led&quot;), gpio_read(25));
}


int main(void) {
  
  mongoose_init();

  mongoose_add_ws_handler(200, ws_200);
  mongoose_add_ws_handler(500, ws_500);

  for (;;) {
    mongoose_poll();
  }
}
</code></pre>
<h2 id="supported-boards">Supported boards</h2>
<p>Below is the list of development boards Mongoose Wizard supports.</p>
<table>
<thead>
<tr>
<th>Architecture</th>
<th>Board</th>
<th>Connectivity</th>
</tr>
</thead>
<tbody><tr>
<td>STM32</td>
<td>Nucleo-F207ZG</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-F207ZG</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-F429ZI</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-F439ZI</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-F746ZG</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-F756ZG</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-F767ZI</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-H563ZI</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-H723ZG</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-H743ZI</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-H753ZI</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-H755ZI-Q</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>Nucleo-H7S3L8</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>STM32H735G-DK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>STM32H745I-DISCO</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>STM32H747I-DISCO</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>STM32</td>
<td>STM32H573I-DK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>Teensy4.1</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1170-EVKB</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1020-EVK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1024-EVK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1040-EVK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1050-EVKB</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1060-EVKB</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>RT1064-EVK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>FRDM-MCXN947</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>NXP</td>
<td>FRDM-RW612</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Texas Instruments</td>
<td>EK-TM4C1294XL</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Texas Instruments</td>
<td>TMS570</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Espressif</td>
<td>ESP32, ESP32xx</td>
<td>Built-in WiFi</td>
</tr>
<tr>
<td>Infineon</td>
<td>XMC4400 2Go</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Infineon</td>
<td>XMC4700 2Go</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Infineon</td>
<td>KIT_XMC72_EVK</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Raspberry PI</td>
<td>RP2040, RP2350</td>
<td>W5500, W5100 Ethernet</td>
</tr>
<tr>
<td>Raspberry PI</td>
<td>Pico-W, Pico2-W</td>
<td>CYW43439 WiFi</td>
</tr>
<tr>
<td>Nordic</td>
<td>nRF9160 Thingy:91</td>
<td>Built-in Cellular</td>
</tr>
<tr>
<td>Renesas</td>
<td>RA6M4</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Zephyr</td>
<td>any</td>
<td>Built-in Ethernet</td>
</tr>
<tr>
<td>Zephyr</td>
<td>any</td>
<td>W5500    Ethernet</td>
</tr>
<tr>
<td>Arduino</td>
<td>any</td>
<td>W5500 Ethernet</td>
</tr>
<tr>
<td>Arduino</td>
<td>any</td>
<td>any WiFI (e.g. ESP32)</td>
</tr>
<tr>
<td>Windows</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Linux,MacOS</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="faq">FAQ</h2>
<ul>
<li>Question: can I manually edit the wizard-generated UI ?</li>
<li>Answer: no you cannot. The Wizard does not generate HTML. Instead, the Wizard UI engine renders the configuration <code>ui</code> section dynamically. If you want full manual control over your UI, do not use the Wizard and create your own UI manually, see the <a href="tutorials/device-dashboard/#frontend-implementation">device dashboard tutorial</a></li>
</ul>



<h1 id="tutorials">Tutorials</h1>
<h2 id="development-environment">Development Environment</h2>
<ul>
<li><a href="tutorials/tools/">Build tools</a> - A guide on setting up a development environment for building and running Mongoose Library examples, as well as developing new applications.</li>
</ul>
<h2 id="web-user-interface">Web User Interface</h2>
<ul>
<li><a href="tutorials/device-dashboard/">Device dashboard</a> - This tutorial shows an example of how to build a device dashboard, what can be very useful for headless devices.</li>
<li><a href="tutorials/webui/webui-rest/">REST basics</a> - This tutorial will show you the basics of how to implement and use a REST-based user interface (UI).</li>
<li><a href="tutorials/webui/webui-plain/">Pure JavaScript UI</a> - This tutorial will show you how to implement a plain JavaScript-based user interface (UI) over a REST-based backend.</li>
<li><a href="tutorials/webui/webui-preact/">Preact UI</a> - This tutorial will show you how to implement a Preact-based frontend for a user interface (UI) over a REST-based backend. We&#39;ll concentrate here on the basics of the Preact UI frontend.</li>
<li><a href="tutorials/webui/webui-login/">User authentication</a> - This tutorial will show you how to implement a session login with a Preact-based user interface (UI) over a REST-based backend. We&#39;ll concentrate here on the basics of the login process.</li>
<li><a href="tutorials/webui/webui-push/">Data push</a> - This tutorial will show you how to push data from the device to a JavaScript-based user interface (UI) running on the browser; either using WebSocket or a REST-based API.</li>
<li><a href="tutorials/mqtt-dashboard/">MQTT dashboard</a> - This tutorial shows an example of how to build a remote device dashboard, what can be very useful to handle remote devices.</li>
</ul>
<h2 id="http">HTTP</h2>
<ul>
<li><a href="tutorials/http/http-server/">HTTP server</a> - A basic HTTP server tutorials will show you how to configure a HTTP server, while you get familiar with the event manager and the server API.</li>
<li><a href="tutorials/http/http-client/">HTTP client</a> - This tutorial will show you how to implement an HTTP client using Mongoose Library.</li>
<li><a href="tutorials/http/http-proxy-client/">HTTP proxy client</a> - This tutorial will show you how to use Mongoose as an HTTP client in places where connections must be done through a proxy. </li>
<li><a href="tutorials/http/http-reverse-proxy/">HTTP reverse proxy</a> - This tutorial will show you how to use Mongoose to implement a reverse proxy.</li>
<li><a href="tutorials/http/file-uploads/">File uploads</a> - This tutorial will show you how to upload a file to a Mongoose web server.</li>
<li><a href="tutorials/http/huge-response/">Huge response</a> - This tutorial will show you how to send large amounts of data, larger than available buffer memory. </li>
<li><a href="tutorials/http/video-stream/">Video stream</a> - This tutorial will show you how to send a video stream as a series of MJPEG frames.</li>
</ul>
<h2 id="websocket">Websocket</h2>
<ul>
<li><a href="tutorials/websocket/websocket-server/">Websocket server</a> - This tutorial demonstrates how Mongoose Library can be used to implement a Websocket server.</li>
<li><a href="tutorials/websocket/websocket-client/">Websocket client</a> - This tutorial demonstrates how Mongoose Library can be used to implement a Websocket client.</li>
<li><a href="tutorials/websocket/json-rpc-over-websocket/">JSON-RPC over WS</a> - This tutorial demonstrates how Mongoose Library can be used to implement JSON-RPC functionality over WebSocket.</li>
</ul>
<h2 id="mqtt">MQTT</h2>
<ul>
<li><a href="tutorials/mqtt/mqtt-client/">MQTT client</a> - This tutorial demonstrates how Mongoose Library can be used to implement an MQTT client.</li>
<li><a href="tutorials/mqtt/mqtt-server/">MQTT server</a> - This tutorial demonstrates how Mongoose Library can be used to implement a simple MQTT 3.1.1 server.</li>
<li><a href="tutorials/mqtt/mqtt-over-ws-client/">MQTT over WS client</a> - This tutorial demonstrates how Mongoose Library can be used to implement an MQTT client that connects to the broker over WebSocket.</li>
<li><a href="tutorials/mqtt/mqtt-client-aws-iot/">AWS IoT</a> - This tutorial demonstrates how Mongoose Library can be used to communicate with the AWS IoT service.</li>
<li><a href="tutorials/mqtt-dashboard/">MQTT dashboard</a> - This tutorial shows an example of how to build an MQTT-controlled headless device.</li>
</ul>
<h2 id="ssltls">SSL/TLS</h2>
<ul>
<li><a href="tutorials/tls/">SSL/TLS</a> - In this tutorial we describe how to enable SSL/TLS for servers and clients.</li>
</ul>
<h2 id="firmware-update">Firmware Update</h2>
<ul>
<li><a href="tutorials/firmware-update/">Firmware Update</a> - This tutorial will show you how to use Mongoose Library functions to implement firmware updates.</li>
</ul>
<h2 id="core">Core</h2>
<ul>
<li><a href="tutorials/core/timers/">Timers</a> - This tutorial will guide you to configure a timer callback, a mechanism to perform some periodic actions.</li>
<li><a href="tutorials/core/multi-threaded/">Multithreading</a> - This tutorial will show you how to work with Mongoose on a multithreaded environment.</li>
<li><a href="tutorials/core/embedded-filesystem/">Embedded filesystem</a> - This tutorial shows an example of how to embed files in a packed filesystem that is linked into the server binary; forming a read-only file system that can be used to hold credentials and/or web files to be served.</li>
</ul>
<h2 id="misc">Misc</h2>
<ul>
<li><a href="tutorials/error-handling/">Error handling</a> - If a connection fails for some reason, you can find answers what to do in this section.</li>
<li><a href="tutorials/uart-bridge/">UART bridge</a> - This tutorial shows an example of how to send UART data over the network.</li>
<li><a href="tutorials/cmsis_driver/">CMSIS driver</a> - Write your own driver, port our generic CMSIS-Driver to your ARM device</li>
</ul>
<h2 id="smtp">SMTP</h2>
<ul>
<li><a href="tutorials/smtp/smtp-client/">SMTP client</a> - This simple tutorial demonstrates how Mongoose Library can be used to implement an SMTP client over TLS.</li>
</ul>
<h2 id="tcp">TCP</h2>
<ul>
<li><a href="tutorials/tcp/tcp/">TCP client and server</a> - This simple tutorial demonstrates how Mongoose Library can be used to implement TCP clients and servers, even over TLS.</li>
<li><a href="tutorials/tcp/socks5-server/">SOCKS5 server</a> - This tutorial will show you how to use Mongoose Library functions to implement a TCP-based server, in this case a SOCKS5 proxy server.</li>
</ul>
<h2 id="udp">UDP</h2>
<ul>
<li><a href="tutorials/udp/captive-dns-server/">Captive DNS server</a> - This tutorial demonstrates how Mongoose Library can be used to implement a captive DNS portal. It is usually required for device configuration. </li>
<li><a href="tutorials/udp/sntp-time-sync/">SNTP time sync</a> - This tutorial will show you how to synchronize time with a remote SNTP server.</li>
<li><a href="tutorials/udp/ssdp-search/">SSDP search</a> - This tutorial demonstrates how to use Mongoose Library for UDP communication, by performing an SSDP search.</li>
</ul>
<h2 id="tcpip-stack-drivers">TCP/IP stack drivers</h2>
<ul>
<li><a href="tutorials/cmsis_driver/">CMSIS Driver</a> - Write your own driver, port our generic CMSIS-Driver to your ARM device</li>
<li><a href="tutorials/rp2040/pico-rndis-dashboard/">Driver for RNDIS</a> - Write your own driver, use TinyUSB and use your computer to control your device via USB</li>
<li><a href="tutorials/rp2040/pico-rmii/">RMII driver with the RP2040 PIOs</a> - Write your own driver, low-level drive of a PHY chip with a software minimalistic MAC controller</li>
<li><a href="tutorials/hardware/">Ethernet Hardware</a> - Configure Mongoose for your own board, in case it is not a standard board supported by <a href="#mongoose-wizard">Mongoose Wizard</a></li>
</ul>
<h2 id="stm32">STM32</h2>
<ul>
<li><a href="tutorials/stm32/all-make-baremetal-builtin/">GCC+make/baremetal</a> - Use Mongoose baremetal on STM32 devices with GCC and make</li>
<li><a href="tutorials/stm32/all-make-freertos-builtin/">GCC+make/FreeRTOS</a> - Use Mongoose over FreeRTOS on STM32 devices with GCC and make</li>
<li><a href="tutorials/stm32/all-cube-baremetal-builtin/">CubeIDE/baremetal</a> - Use Mongoose baremetal on STM32 devices with STM32CubeIDE</li>
<li><a href="tutorials/stm32/all-cube-freertos-builtin/">CubeIDE/FreeRTOS</a> - Use Mongoose over FreeRTOS on STM32 devices with STM32CubeIDE</li>
<li><a href="/documentation/tutorials/stm32/cube/">CubeIDE step-by-step</a></li>
<li><a href="/documentation/tutorials/stm32/nucleo-f746zg-keil-baremetal/">Keil/baremetal</a> - Use Mongoose baremetal on STM32 devices with Keil</li>
<li><a href="https://mongoose.ws/documentation/#nucleo-f746zg">Keil/more options</a> - Check the F746 to see several tutorials on how to use Mongoose over an OS on STM32 devices with Keil</li>
<li><a href="/documentation/tutorials/stm32/keil/">Keil step-by-step</a></li>
</ul>
<h3 id="nucleo-f207zg">Nucleo-F207ZG</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 128k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 120MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/258;" class="mw-100 mh-100">
<img src="images/nucleo-f746zg.webp" alt="Nucleo-F207ZG board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f207&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f207&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f207&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f207&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=f207&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-f429zi">Nucleo-F429ZI</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 180MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/258;" class="mw-100 mh-100">
<img src="images/nucleo-f746zg.webp" alt="Nucleo-F429ZI board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f429&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f429&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f429&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f429&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/all-cube-freertos-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-baremetal/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos/">tutorial</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=f429&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in USB</td>
<td><a href="tutorials/stm32/all-make-baremetal-builtin-rndis/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-f429zi--rm2-breakout">Nucleo-F429ZI + RM2 breakout</h3>
<div class="text-end">
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 250/291;" class="mw-100 mh-100">
<img src="images/rm2-breakout.webp" alt="RM2 breakout" class="w-50 h-50 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/rm2-nucleo-f429zi-make-baremetal-builtin/">example</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-f439zi">Nucleo-F439ZI</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 180MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/258;" class="mw-100 mh-100">
<img src="images/nucleo-f746zg.webp" alt="Nucleo-F439ZI board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f439&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f439&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f439&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f439&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/all-cube-freertos-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-baremetal/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos/">tutorial</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=f439&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in USB</td>
<td><a href="tutorials/stm32/all-make-baremetal-builtin-rndis/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-f746zg">Nucleo-F746ZG</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 320k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 216MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/258;" class="mw-100 mh-100">
<img src="images/nucleo-f746zg.webp" alt="Nucleo-F746ZG board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f746&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f746&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f746&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f746&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/all-cube-freertos-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-baremetal/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>CMSIS-RTOS v1 (RTX)</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-cmsis1/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>CMSIS-RTOS v2</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-cmsis2/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>CMSIS-RTOS v2</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-cmsis2-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>FreeRTOS+TCP</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos-tcp/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>RTX</td>
<td>MDK</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-rtx-mdk/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>RTX5</td>
<td>MDK</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-rtx5-mdk/">tutorial</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=f746&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>FreeRTOS+TCP</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/nucleo-f746zg-make-freertos-tcp">example</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in USB</td>
<td><a href="tutorials/stm32/all-make-baremetal-builtin-rndis/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-f746zg--rm2-breakout">Nucleo-F746ZG + RM2 breakout</h3>
<div class="text-end">
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 250/291;" class="mw-100 mh-100">
<img src="images/rm2-breakout.webp" alt="RM2 breakout" class="w-50 h-50 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/rm2-nucleo-f746zg-make-baremetal-builtin/">example</a></td>
</tr>
</tbody></table>
</div></div>


<h3 id="nucleo-f756zg">Nucleo-F756ZG</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 320k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 216MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/258;" class="mw-100 mh-100">
<img src="images/nucleo-f746zg.webp" alt="Nucleo-F756ZG board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f756&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f756&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f756&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f756&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/all-cube-freertos-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f756&ide=Keil&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>CMSIS-RTOS v1 (RTX)</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-cmsis1/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>CMSIS-RTOS v2</td>
<td>built-in</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-cmsis2/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>CMSIS-RTOS v2</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-cmsis2-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos-lwip/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>FreeRTOS</td>
<td>FreeRTOS+TCP</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-freertos-tcp/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>RTX</td>
<td>MDK</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-rtx-mdk/">tutorial</a></td>
</tr>
<tr>
<td>Keil</td>
<td>RTX5</td>
<td>MDK</td>
<td><a href="tutorials/stm32/nucleo-f746zg-keil-rtx5-mdk/">tutorial</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=f756&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>FreeRTOS+TCP</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/nucleo-f746zg-make-freertos-tcp">example</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in USB</td>
<td><a href="tutorials/stm32/all-make-baremetal-builtin-rndis/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-f767zi">Nucleo-F767ZI</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 512k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 216MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/258;" class="mw-100 mh-100">
<img src="images/nucleo-f746zg.webp" alt="Nucleo-F767ZI board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f767&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f767&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f767&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=f767&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=f767&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/all-cube-freertos-lwip/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-h563zi">Nucleo-H563ZI</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 640k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 250MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 547/281;" class="mw-100 mh-100">
<img src="images/nucleo-h563zi.webp" alt="Nucleo-H563ZI board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h563&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h563&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h563&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h563&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h563&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="stm32h573i-dk">STM32H573I-DK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 640k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 250MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 1000/687;" class="mw-100 mh-100">
<img src="images/stm32h573i-dk.webp" alt="STM32H573I-DK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h573&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h573&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h573&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h573&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h573&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-h723zg">Nucleo-H723ZG</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 564k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 550MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/237;" class="mw-100 mh-100">
<img src="images/nucleo-h743z.webp" alt="Nucleo-H723ZG board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h723&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h723&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h723&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h723&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h723&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/stm32/all-make-baremetal-builtin/">device dashboard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/mqtt-dashboard/#device-implementation">MQTT dashboard device</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="stm32h735g-dk">STM32H735G-DK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 564k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 550MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 981/635;" class="mw-100 mh-100">
<img src="images/stm32h735g-dk.webp" alt="STM32H735G-DK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h735&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h735&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h735&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h735&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h735&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-h743zi2">Nucleo-H743ZI2</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 480MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/237;" class="mw-100 mh-100">
<img src="images/nucleo-h743z.webp" alt="Nucleo-H743ZI2 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h743&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h743&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h743&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h743&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h743&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/stm32/all-cube-freertos-lwip/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="stm32h745i-disco">STM32H745I-Disco</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 480MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 500/372;" class="mw-100 mh-100">
<img src="images/stm32h745i-disco.webp" alt="H745I-DISCO board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h745&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h745&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h745&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h745&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h745&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="stm32h747i-disco">STM32H747I-Disco</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 480MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 500/372;" class="mw-100 mh-100">
<img src="images/h747i-disco.webp" alt="H747I-DISCO board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h747&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h747&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h747&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h747&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h747&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="arduino-portenta-h7">Arduino Portenta H7</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 400MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 457/187;" class="mw-100 mh-100">
<img src="images/portenta-h7.webp" alt="Arduino Portenta H7" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/portenta-h7-make-baremetal-builtin/">example</a></td>
</tr>
<tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/portenta-h7-cube-baremetal-builtin/">example</a></td>
</tr>
</tbody></table>
</div></div>


<h3 id="nucleo-h753zi">Nucleo-H753ZI</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 480MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 400/237;" class="mw-100 mh-100">
<img src="images/nucleo-h743z.webp" alt="Nucleo-H753ZI board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h753&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h753&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h753&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h753&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h753&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-h755zi-q">Nucleo-H755ZI-Q</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 480MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 754/393;" class="mw-100 mh-100">
<img src="images/nucleo-h755zi-q.webp" alt="Nucleo-H755ZI-Q board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Cube</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h755&ide=CubeIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Cube</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h755&ide=CubeIDE&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h755&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h755&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=h755&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-h7s3l8">Nucleo-H7S3L8</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 620k</span>
<span class="badge bg-secondary">flash: 64k</span>
<span class="badge bg-secondary">freq: 600MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 609/339;" class="mw-100 mh-100">
<img src="images/nucleo-h7s3l8.webp" alt="Nucleo-H7S3L8 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=h7s3l8&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="nucleo-g031k8--w5500-module">Nucleo-G031K8 + W5500 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 8k</span>
<span class="badge bg-secondary">flash: 64k</span>
<span class="badge bg-secondary">freq: 64MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-2">
<div style="aspect-ratio: 345/344;" class="mw-100 mh-100">
<img src="images/nucleo-g031k8+w5500.webp" alt="Nucleo-G031K8 board + W5500 mini" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/stm32/nucleo-g031-make-baremetal-builtin/">example</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="nxp">NXP</h2>
<h3 id="frdm-mcxn947">FRDM-MCXN947</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 512k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 672/313;" class="mw-100 mh-100">
<img src="images/FRDM-MCXN947.webp" alt="NXP FRDM-MCXN947 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=mcxn947&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=mcxn947&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=mcxn947&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=mcxn947&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=mcxn947&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="frdm-rw612">FRDM-RW612</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1.2m</span>
<span class="badge bg-secondary">flash: 64m</span>
<span class="badge bg-secondary">freq: 260MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 795/386;" class="mw-100 mh-100">
<img src="images/frdm-rw612.webp" alt="NXP FRDM-RW612 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rw612&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rw612&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>lwIP (Ethernet)</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/nxp/frdm-rw612-xpresso-freertos-lwip/">example</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>lwIP (Wi-Fi)</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/nxp/frdm-rw612-xpresso-freertos-lwip-wifi/">example</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1020-evk">MIMXRT1020-EVK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 8m</span>
<span class="badge bg-secondary">freq: 500MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 400/271;" class="mw-100 mh-100">
<img src="images/mimxrt1020-evk.webp" alt="NXP MIMXRT1020-EVK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1020&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1020&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1020&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1020&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/nxp/nxp-mimxrt1020-freertos/">tutorial</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>AzureRTOS</td>
<td>Azure</td>
<td><a href="tutorials/nxp/nxp-mimxrt1020-azurertos/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1024-evk">MIMXRT1024-EVK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 500MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 468/304;" class="mw-100 mh-100">
<img src="images/mimxrt1024-evk.webp" alt="NXP MIMXRT1024-EVK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1024&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1024&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1024&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1024&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1040-evk">MIMXRT1040-EVK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 512k</span>
<span class="badge bg-secondary">flash: 8m</span>
<span class="badge bg-secondary">freq: 600MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 596/391;" class="mw-100 mh-100">
<img src="images/mimxrt1040-evk.webp" alt="NXP MIMXRT1040-EVK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1040&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1040&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1040&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1040&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1050-evkb">MIMXRT1050-EVKB</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 64m</span>
<span class="badge bg-secondary">freq: 600MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 695/470;" class="mw-100 mh-100">
<img src="images/mimxrt1050-evkb.webp" alt="NXP MIMXRT1050-EVKB board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1050&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1050&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1050&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1050&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1060-evkb">MIMXRT1060-EVKB</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 512k</span>
<span class="badge bg-secondary">flash: 8m</span>
<span class="badge bg-secondary">freq: 600MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 506/290;" class="mw-100 mh-100">
<img src="images/mimxrt1060-evkb.webp" alt="NXP MIMXRT1060-EVKB board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1060&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1060&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1060&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1060&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/nxp/rt1060-evk-xpresso-baremetal-builtin/">example</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=rt1060&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1064-evk">MIMXRT1064-EVK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 512k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 600MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 719/488;" class="mw-100 mh-100">
<img src="images/mimxrt1064-evk.webp" alt="NXP MIMXRT1064-EVK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1064&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1064&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1064&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1064&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=rt1064&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="mimxrt1170-evkb">MIMXRT1170-EVKB</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 64m</span>
<span class="badge bg-secondary">flash: tons</span>
<span class="badge bg-secondary">freq: 1GHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 585/484;" class="mw-100 mh-100">
<img src="images/mimxrt1170-evkb.webp" alt="NXP MIMXRT1170-EVKB board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1170&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1170&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1170&ide=MCUXpresso&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=rt1170&ide=MCUXpresso&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="teensy-41--expansion-board">Teensy 4.1 + expansion board</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 8m</span>
<span class="badge bg-secondary">freq: 600MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 476/282;" class="mw-100 mh-100">
<img src="images/teensy41exp.webp" alt="Teensy 4.1 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Arduino</td>
<td></td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=teensy41&ide=Arduino&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="frdm-k64f">FRDM-K64F</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 120MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-5">
<div style="aspect-ratio: 250/209;" class="mw-100 mh-100">
<img src="images/frdm-k64f.webp" alt="NXP FRDM-K64F board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/nxp/nxp-frdmk64f-lwip-freertos">example</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="frdm-k66f">FRDM-K66F</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 180MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 287/198;" class="mw-100 mh-100">
<img src="images/frdm-k66f.webp" alt="NXP FRDM-K66F board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/nxp/nxp-frdmk66f-freertos/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>


<h3 id="nxp-lpc54s018m-evk">NXP LPC54S018M-EVK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 128m</span>
<span class="badge bg-secondary">flash: 128m</span>
<span class="badge bg-secondary">freq: 180MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 400/301;" class="mw-100 mh-100">
<img src="images/lpc54018.webp" alt="NXP LPC54S018M-EVK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>MCUXpresso</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/nxp/nxp-lpcxpresso54s018m-freertos/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="esp">ESP</h2>
<h3 id="esp32-devkitc">ESP32 DevkitC</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 220k</span>
<span class="badge bg-secondary">flash: 2/4m@40MHz</span>
<span class="badge bg-secondary">freq: 160/240MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 300/225;" class="mw-100 mh-100">
<img src="images/esp32.webp" alt="ESP32 DevkitC board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/esp32/device-dashboard/">device dashboard</a></td>
</tr>
<tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/esp32/uart-bridge/">UART bridge</a></td>
</tr>
<tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="/wizard/#/output?board=esp32&ide=ESP-IDF&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/http/http-server/arduino/esp32-http/">HTTP server</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/mqtt/mqtt-client/arduino/esp32-mqtt/">MQTT</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="/wizard/#/output?board=arduino-esp32&ide=Arduino&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MicroPython</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/micropython/esp32/">module</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="m5-stamp-pico">M5 STAMP PICO</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 220k</span>
<span class="badge bg-secondary">flash: 4m@80MHz</span>
<span class="badge bg-secondary">freq: 240MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 432/614;" class="mw-100 mh-100">
<img src="images/m5_stamp_pico.webp" alt="M5 STAMP PICO board" class="w-50 h-50 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/esp32/device-dashboard/">tutorial</a></td>
</tr>
<tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="/wizard/#/output?board=esp32&ide=ESP-IDF&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/http/http-server/arduino/esp32-http/">HTTP server</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/mqtt/mqtt-client/arduino/esp32-mqtt/">MQTT</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="/wizard/#/output?board=arduino-esp32&ide=Arduino&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MicroPython</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/micropython/esp32/">module</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="xiao-esp32-c3">XIAO-ESP32-C3</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 400k</span>
<span class="badge bg-secondary">flash: 4m@80MHz</span>
<span class="badge bg-secondary">freq: 160MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 250/318;" class="mw-100 mh-100">
<img src="images/xiao_esp32-c3.webp" alt="XIAO-ESP32-C3 board" class="w-50 h-50 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/esp32/device-dashboard/">tutorial</a></td>
</tr>
<tr>
<td>ESP-IDF</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="/wizard/#/output?board=esp32&ide=ESP-IDF&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/http/http-server/arduino/esp32-http/">HTTP server</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/mqtt/mqtt-client/arduino/esp32-mqtt/">MQTT</a></td>
</tr>
<tr>
<td>Arduino</td>
<td></td>
<td></td>
<td><a href="/wizard/#/output?board=arduino-esp32&ide=Arduino&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>MicroPython</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/micropython/esp32/">module</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="esp8266-devkitc">ESP8266 DevkitC</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 50k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 80MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 380/232;" class="mw-100 mh-100">
<img src="images/esp8266-devkitc.webp" alt="ESP8266 DevkitC board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RTOS SDK</td>
<td>SDK (FreeRTOS)</td>
<td>SDK (lwIP)</td>
<td><a href="tutorials/esp8266/http-client-server/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>


<h2 id="texas-instruments">Texas Instruments</h2>
<ul>
<li><a href="tutorials/ti/ek-tm4c1294xl-make-baremetal-builtin/">GCC+make/baremetal</a> - Use Mongoose baremetal on Tiva devices with GCC and make</li>
<li><a href="tutorials/ti/ek-tm4c1294xl-make-freertos-builtin/">GCC+make/FreeRTOS</a> - Use Mongoose over FreeRTOS on Tiva devices with GCC and make</li>
</ul>
<h3 id="ek-tm4c1294xxx">EK-TM4C1294xxx</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 120MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 436/237;" class="mw-100 mh-100">
<img src="images/tm4c129.webp" alt="TI EK-TM4C1294XL board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=tm4c129&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>FreeRTOS</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=tm4c129&ide=GCC+make&rtos=FreeRTOS&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>CCS</td>
<td>TI-RTOS</td>
<td>TI-RTOS</td>
<td><a href="tutorials/ti/ti-ek-tm4c1294xl-http-server/">tutorial</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in USB</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/ti/ek-tm4c1294xl-make-baremetal-builtin-rndis">example</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="tmdx570lc43hdk-tms570">TMDX570LC43HDK (TMS570)</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 512k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 300MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 531/347;" class="mw-100 mh-100">
<img src="images/tmdx570lc43hdk.webp" alt="TMDX570LC43HDK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>CGT+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=tms570&ide=CGT+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="infineon">Infineon</h2>
<h3 id="kit_xmc_plt2go_xmc4400">KIT_XMC_PLT2GO_XMC4400</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 80k</span>
<span class="badge bg-secondary">flash: 512k</span>
<span class="badge bg-secondary">freq: 120MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 600/436;" class="mw-100 mh-100">
<img src="images/xmc4400_2go.webp" alt="Infineon XMC-4400 Platform2GO board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=xmc4400&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Modus IDE</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=xmc4400&ide=ModusIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="kit_xmc47_relax_v1">KIT_XMC47_RELAX_V1</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 352k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 144MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 280/197;" class="mw-100 mh-100">
<img src="images/xmc47_relax.webp" alt="Infineon KIT_XMC47_RELAX_V1 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=xmc4700&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Modus IDE</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=xmc4700&ide=ModusIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="kit_xmc72_evk">KIT_XMC72_EVK</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 8m</span>
<span class="badge bg-secondary">freq: 350MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 592/333;" class="mw-100 mh-100">
<img src="images/kit_xmc72_evk.webp" alt="Infineon XMC-7200 EVK board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=xmc7200&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Modus IDE</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=xmc7200&ide=ModusIDE&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="cy8cproto-062-4343w">CY8CPROTO-062-4343W</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 610/416;" class="mw-100 mh-100">
<img src="images/CY8CPROTO-062-4343W.webp" alt="Infineon CY8CPROTO-062-4343W board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<p>SOON...</p>
</div></div>

<h3 id="cy8cproto-062s2-43439">CY8CPROTO-062S2-43439</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1m</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 610/422;" class="mw-100 mh-100">
<img src="images/CY8CPROTO-062S2-43439.webp" alt="Infineon CY8CPROTO-062S2-43439 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<p>SOON...</p>
</div></div>

<h2 id="nordic-semiconductor">Nordic Semiconductor</h2>
<h3 id="nordic-thingy91">Nordic Thingy:91</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 64MHz</span>
<span class="badge bg-success text-light">net: Cellular</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container py-3 px-4">
<div style="aspect-ratio: 350/367;" class="mw-100 mh-100">
<img src="images/Thingy91_board.webp" alt="Nordic Thingy:91 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=nrf91&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="raspberry-pi-rpxxxx">Raspberry Pi RPxxxx</h2>
<h3 id="pico-rp2040">Pico (RP2040)</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-danger text-light">net: USB (RNDIS/CDC-ECM)</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 1024/789;" class="mw-100 mh-100">
<img src="images/pico.webp" alt="Raspberry Pi Pico board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in USB RNDIS</td>
<td><a href="tutorials/rp2040/pico-rndis-dashboard/">device dashboard</a></td>
</tr>
<tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in USB RNDIS</td>
<td><a href="tutorials/mqtt-dashboard/#device-implementation">MQTT dashboard device</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico-2-rp2350">Pico 2 (RP2350)</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 520k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<!--span class="badge bg-danger text-light">net: USB (RNDIS/CDC-ECM)</span-->
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 699/499;" class="mw-100 mh-100">
<img src="images/pico-2.webp" alt="Raspberry Pi Pico 2 board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">


</div></div>

<h3 id="pico-w-rp2040">Pico W (RP2040)</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 400/267;" class="mw-100 mh-100">
<img src="images/pico-w.webp" alt="Raspberry Pi Pico W board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>Baremetal</td>
<td>builtin</td>
<td><a href="/wizard/#/output?board=pico-w&ide=Pico-SDK&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>RPI PICO C SDK</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/rp2040/pico-w/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico-2-w-rp2350">Pico 2 W (RP2350)</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 520k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 492/347;" class="mw-100 mh-100">
<img src="images/pico-2-w.webp" alt="Raspberry Pi Pico 2 W board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>Baremetal</td>
<td>builtin</td>
<td><a href="/wizard/#/output?board=pico2-w&ide=Pico-SDK&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>RPI PICO C SDK</td>
<td>FreeRTOS</td>
<td>lwIP</td>
<td><a href="tutorials/rp2040/pico-w/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico--lan8720-module">Pico + LAN8720 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 240/179;" class="mw-100 mh-100">
<img src="images/pico+LAN8720.webp" alt="Raspberry Pi Pico and LAN8720 module board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/rp2040/pico-rmii/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico--w5500-module">Pico + W5500 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 233/179;" class="mw-100 mh-100">
<img src="images/pico+W5500.webp" alt="Raspberry Pi Pico and W5500 module board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/rp2040/pico-w5500/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="w5500-evb-pico">W5500-EVB-Pico</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 570/330;" class="mw-100 mh-100">
<img src="images/w5500-evb-pico.webp" alt="W5500-EVB-Pico (RP2040 + W5500) board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=evb-pico&ide=Pico-SDK&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
<tr>
<td>Zephyr</td>
<td>Zephyr</td>
<td>Zephyr</td>
<td><a href="/wizard/#/output?board=evb-pico&ide=Zephyr&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico--w5100-module">Pico + W5100 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 218/169;" class="mw-100 mh-100">
<img src="images/pico+W5100.webp" alt="Raspberry Pi Pico and W5100 module board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/rp2040/pico-w5100/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="w5100s-evb-pico">W5100S-EVB-Pico</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 751/418;" class="mw-100 mh-100">
<img src="images/w5100s-evb-pico.webp" alt="W5100S-EVB-Pico (RP2040 + W5100) board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/rp2040/pico-w5100/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico--rm2-breakout">Pico + RM2 breakout</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 250/291;" class="mw-100 mh-100">
<img src="images/rm2-breakout.webp" alt="RM2 breakout" class="w-50 h-50 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/picosdk/rm2-pico-picosdk-make-baremetal-builtin/">example</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico-2--w5500-module">Pico 2 + W5500 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 520k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 233/179;" class="mw-100 mh-100">
<img src="images/pico-2+W5500.webp" alt="Raspberry Pi Pico 2 and W5500 module board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/rp2040/pico-w5500/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="w5500-evb-pico2">W5500-EVB-Pico2</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 520k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 618/300;" class="mw-100 mh-100">
<img src="images/w5500-evb-pico2.webp" alt="W5500-EVB-Pico2 (RP2350 + W5500) board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=evb-pico2&ide=Pico-SDK&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="pico-2--w5100-module">Pico 2 + W5100 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 520k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 246/198;" class="mw-100 mh-100">
<img src="images/pico-2+W5100.webp" alt="Raspberry Pi Pico 2 and W5100 module board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="tutorials/rp2040/pico-w5100/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="w5100s-evb-pico2">W5100S-EVB-Pico2</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 520k</span>
<span class="badge bg-secondary">flash: 4m</span>
<span class="badge bg-secondary">freq: 150MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 618/290;" class="mw-100 mh-100">
<img src="images/w5100s-evb-pico2.webp" alt="W5100S-EVB-Pico2 (RP2350 + W5100) board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="/wizard/#/output?board=evb-pico2-w5100&ide=Pico-SDK&rtos=baremetal&file=README.md">Wizard</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="xiao-rp2040">XIAO RP2040</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 264k</span>
<span class="badge bg-secondary">flash: 2m</span>
<span class="badge bg-secondary">freq: 133MHz</span>
<span class="badge bg-danger text-light">net: USB (RNDIS/CDC-ECM)</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-3">
<div style="aspect-ratio: 441/374;" class="mw-100 mh-100">
<img src="images/xiao_rp2040.webp" alt="Seeed Xiao RP2040 board" class="w-50 h-50 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>RPI PICO C SDK</td>
<td>baremetal</td>
<td>built-in USB RNDIS</td>
<td><a href="tutorials/rp2040/pico-rndis-dashboard/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="microchip-samxx">Microchip SAMxx</h2>
<h3 id="sam-e54-xplained-pro">SAM E54 Xplained Pro</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 256k</span>
<span class="badge bg-secondary">flash: 1m</span>
<span class="badge bg-secondary">freq: 120MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-2">
<div style="aspect-ratio: 400/251;" class="mw-100 mh-100">
<img src="images/same54-xpro.webp" alt="SAM E54 Xplained Pro" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/http/device-dashboard/microchip/same54-xpro">device dashboard</a></td>
</tr>
<tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/mqtt/mqtt-client/microchip/same54-xpro">MQTT client</a></td>
</tr>
</tbody></table>
</div></div>

<h3 id="xiao-m0--w5500-module">XIAO M0 + W5500 module</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 32k</span>
<span class="badge bg-secondary">flash: 256k</span>
<span class="badge bg-secondary">freq: 48MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-2">
<div style="aspect-ratio: 400/166;" class="mw-100 mh-100">
<img src="images/xiao-w5500.webp" alt="XIAO M0 + W5500 module board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Arduino</td>
<td></td>
<td>built-in</td>
<td><a href="tutorials/arduino/w5500-http/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="wch">WCH</h2>
<h3 id="ch32v307">CH32V307</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 64k</span>
<span class="badge bg-secondary">flash: 256k</span>
<span class="badge bg-secondary">freq: 144MHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container">
<div style="aspect-ratio: 839/591;" class="mw-100 mh-100">
<img src="images/wch-ch32v307.webp" alt="WCH CH32V307 board" class="w-100 h-100 board-image" />
</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>OS</th>
<th>IP stack</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>GCC+make</td>
<td>baremetal</td>
<td>built-in</td>
<td><a href="https://github.com/cesanta/mongoose/tree/master/tutorials/wch/ch32v307-make-baremetal-builtin/">example</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="zephyr">Zephyr</h2>
<ul>
<li><a href="tutorials/zephyr/device-dashboard/">Tutorial</a></li>
</ul>
<h2 id="windows">Windows</h2>
<ul>
<li><a href="/wizard/#/output?board=windows&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></li>
</ul>
<h2 id="mac-and-linux">Mac and Linux</h2>
<ul>
<li><a href="/wizard/#/output?board=unix&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></li>
</ul>
<h2 id="embedded-linux">Embedded Linux</h2>
<h3 id="raspberry-pi">Raspberry Pi</h3>
<div class="text-end">
<span class="badge bg-secondary">ram: 1G</span>
<span class="badge bg-secondary">flash: SD</span>
<span class="badge bg-secondary">freq: 1.2+ GHz</span>
<span class="badge bg-warning text-dark">net: Ethernet</span>
<span class="badge bg-info text-light">net: WiFi</span>
</div>

<div class="row">
<div class="col-md-4">

<div class="board-image-container px-4">
<div style="aspect-ratio: 400/257;" class="mw-100 mh-100">
<img src="images/raspberry_pi_4b.webp" alt="Raspberry Pi 4B board" class="w-100 h-100 board-image" />

</div>
</div>

</div>
<div class="col">

<table>
<thead>
<tr>
<th>Framework</th>
<th>Code</th>
<th>Tutorial</th>
</tr>
</thead>
<tbody><tr>
<td>Raspberry Pi OS</td>
<td><a href="/wizard/#/output?board=unix&ide=GCC+make&rtos=baremetal&file=README.md">Wizard</a></td>
<td><a href="tutorials/raspberry-pi/rp/">tutorial</a></td>
</tr>
</tbody></table>
</div></div>

<h2 id="video-tutorials">Video Tutorials</h2>
<div class="row">
<div class="col-4">
        <div class="position-relative rounded h-100">
          <div style="aspect-ratio: 350/197;" class="mw-100 mh-100">
            <a href="https://www.youtube.com/watch?v=rjNwF8iWp7Q"><img src="images/0.webp" class="h-100 w-100" alt="Mongoose WebServer for Microcontrollers - setting up tools on Windows and building a basic example."></a>
          </div>
          </div>
</div>
<div class="col-7">
<p class="p-2 pb-0">Introduction - setting up tools on Windows and
          building a basic example</p>
 </div>
 </div>

<div class="row">
      <div class="col-4">
          <div style="aspect-ratio: 350/197;" class="mw-100 mh-100">
            <a href="https://www.youtube.com/watch?v=2Hq1wc1AzCY"><img src="images/1.webp" class="h-100 w-100" alt="A detailed HTTP server example walk-through."></a>
      </div>
        </div>
      <div class="col-7">
            <p class="p-2 pb-0">A detailed HTTP server example walk-through</p>
       </div>
</div>

<div class="row">
<div class="col-4">
          <div style="aspect-ratio: 350/197;" class="mw-100 mh-100">
            <a href="https://www.youtube.com/watch?v=_NequYNg3Vw"><img src="images/2.webp" class="h-100 w-100" alt="Implementing Web UI device dashboard on STM32F7 board using Keil RTX."></a>
          </div>
</div>
      <div class="col-7">
          <p class="p-2 pb-0">Implementing Web UI device dashboard on STM32F7 board using Keil RTX</p>
       </div>
</div>

<div class="row">
  <div class="col-4">
          <div style="aspect-ratio: 350/197;" class="mw-100 mh-100">
            <a href="https://www.youtube.com/watch?v=8htC_TSBeO0"><img src="images/3.webp" class="h-100 w-100" alt="Implementing Web UI device dashboard on STM32F7 board using Cube IDE."></a>
          </div>
         
  </div>
        <div class="col-7">
            <p class="p-2 pb-0">Implementing Web UI device dashboard on STM32F7 board using Cube IDE</p>
       </div>
</div>

<div class="row">
  <div class="col-4">
          <div style="aspect-ratio: 350/197;" class="mw-100 mh-100">
            <a href="https://www.youtube.com/watch?v=Yz8kg8-mi-Q"><img src="images/4.webp" class="h-100 w-100" alt="How does TCP/CP stack work on embedded device."></a>
          </div>
  </div>
<div class="col-7">
            <p class="p-2 pb-0">How does TCP/CP stack work on embedded device - an animated tutorial</p>
       </div>
</div>

<h1 id="api-reference">API Reference</h1>
<h2 id="core-1">Core</h2>
<h3 id="struct-mg_addr">struct mg_addr</h3>
<pre><code class="language-c">struct mg_addr {
  uint8_t ip[16];    // Holds IPv4 or IPv6 address, in network byte order
  uint16_t port;     // TCP or UDP port in network byte order
  uint8_t scope_id;  // IPv6 scope ID
  bool is_ip6;       // True when address is IPv6 address
};
</code></pre>
<p>This structure contains network address; it can be considered as a Mongoose equivalent for sockets <code>sockaddr</code> structure.</p>
<h3 id="struct-mg_mgr">struct mg_mgr</h3>
<pre><code class="language-c">struct mg_mgr {
  struct mg_connection *conns;  // List of active connections
  struct mg_dns dns4;           // DNS for IPv4
  struct mg_dns dns6;           // DNS for IPv6
  int dnstimeout;               // DNS resolve timeout in milliseconds
  unsigned long nextid;         // Next connection ID
  void *userdata;               // Arbitrary user data pointer
  ...
  struct mg_tcpip_if *ifp;      // Builtin TCP/IP stack only. Interface pointer
};
</code></pre>
<p>Event management structure that holds a list of active connections, together
with some housekeeping information.</p>
<h3 id="struct-mg_connection">struct mg_connection</h3>
<pre><code class="language-c">struct mg_connection {
  struct mg_connection *next;  // Linkage in struct mg_mgr :: connections
  struct mg_mgr *mgr;          // Our container
  struct mg_addr loc;          // Local address
  struct mg_addr rem;          // Remote address
  void *fd;                    // Connected socket, or LWIP data
  unsigned long id;            // Auto-incrementing unique connection ID
  struct mg_iobuf recv;        // Incoming data
  struct mg_iobuf send;        // Outgoing data
  mg_event_handler_t fn;       // User-specified event handler function
  void *fn_data;               // User-specified function parameter
  mg_event_handler_t pfn;      // Protocol-specific handler function
  void *pfn_data;              // Protocol-specific function parameter
  char data[MG_DATA_SIZE];     // Arbitrary connection data, MG_DATA_SIZE defaults to 32 bytes
  void *tls;                   // TLS specific data
  unsigned is_listening : 1;   // Listening connection
  unsigned is_client : 1;      // Outbound (client) connection
  unsigned is_accepted : 1;    // Accepted (server) connection
  unsigned is_resolving : 1;   // Non-blocking DNS resolve is in progress
  unsigned is_connecting : 1;  // Non-blocking connect is in progress
  unsigned is_tls : 1;         // TLS-enabled connection
  unsigned is_tls_hs : 1;      // TLS handshake is in progress
  unsigned is_udp : 1;         // UDP connection
  unsigned is_websocket : 1;   // WebSocket connection
  unsigned is_hexdumping : 1;  // Hexdump in/out traffic
  unsigned is_draining : 1;    // Send remaining data, then close and free
  unsigned is_closing : 1;     // Close and free the connection immediately
  unsigned is_full : 1;        // Stop reads, until cleared
  unsigned is_resp : 1;        // Response is still being generated
  unsigned is_readable : 1;    // Connection is ready to read
  unsigned is_writable : 1;    // Connection is ready to write
};
</code></pre>
<p>A connection - either a listening connection, or an accepted connection,
or an outbound connection.</p>
<h3 id="mg_mgr_init">mg_mgr_init()</h3>
<pre><code class="language-c">void mg_mgr_init(struct mg_mgr *mgr);
</code></pre>
<p>Initialize event manager structure:</p>
<ul>
<li>Set a list of active connections to NULL</li>
<li>Set default DNS servers for IPv4 and IPv6</li>
<li>Set default DNS lookup timeout</li>
</ul>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - a pointer to <code>mg_mgr</code> structure that needs to be initialized</li>
</ul>
<p>Return value: none</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_mgr mgr;
mg_mgr_init(&amp;mgr);
</code></pre>
<h3 id="mg_mgr_poll">mg_mgr_poll()</h3>
<pre><code class="language-c">void mg_mgr_poll(struct mg_mgr *mgr, int ms);
</code></pre>
<p>Perform a single poll iteration. For each connection in the <code>mgr-&gt;conns</code> list:</p>
<ul>
<li>See if there is incoming data. If there is, read it into the <code>c-&gt;recv</code> buffer, send <code>MG_EV_READ</code> event</li>
<li>See if there is data in the <code>c-&gt;send</code> buffer, and write it, send <code>MG_EV_WRITE</code> event</li>
<li>If a connection is listening, accept an incoming connection if any, and send <code>MG_EV_ACCEPT</code> event to it</li>
<li>Send <code>MG_EV_POLL</code> event</li>
</ul>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - an event manager to use</li>
<li><code>ms</code> - a timeout in milliseconds</li>
</ul>
<p>Return value: none</p>
<p>Usage example:</p>
<pre><code class="language-c">while (running == true) mg_mgr_poll(&amp;mgr, 1000 /* 1 sec */);
</code></pre>
<h3 id="mg_mgr_free">mg_mgr_free()</h3>
<pre><code class="language-c">void mg_mgr_free(struct mg_mgr *mgr);
</code></pre>
<p>Close all connections, and free all resources.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - an event manager to cleanup</li>
</ul>
<p>Return value: none</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_mgr mgr;
mg_mgr_init(&amp;mgr);
while (running == true) mg_mgr_poll(&amp;mgr, 1000);   // Event loop
mg_mgr_free(&amp;mgr);
</code></pre>
<h3 id="mg_listen">mg_listen()</h3>
<pre><code class="language-c">struct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,
                                mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Create a listening connection, append this connection to <code>mgr-&gt;conns</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - an event manager to use</li>
<li><code>url</code> - a URL. Specifies local IP address and port to listen on, e.g.
<code>tcp://127.0.0.1:1234</code> or <code>udp://0.0.0.0:9000</code>. If this URL is a known TLS URL, the <code>is_tls</code> flag will be set</li>
<li><code>fn</code> - an event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: created connection, or <code>NULL</code> on error.</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_connection *c = mg_listen(&amp;mgr, &quot;tcp://127.0.0.1:8080&quot;, fn, NULL);
</code></pre>
<h3 id="mg_connect">mg_connect()</h3>
<pre><code class="language-c">struct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,
                                 mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Create an outbound connection, append this connection to <code>mgr-&gt;conns</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - An event manager to use</li>
<li><code>url</code> - A URL, specifies remote IP address/port to connect to, e.g. <code>http://a.com</code>. If this URL is a known TLS URL, the <code>is_tls</code> flag will be set</li>
<li><code>fn</code> - An event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: created connection, or <code>NULL</code> on error.</p>
<p>Note: This function does not connect to peer, it allocates required resources and
starts connect process. Once peer is really connected, <code>MG_EV_CONNECT</code> event is sent
to connection event handler.</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_connection *c = mg_connect(&amp;mgr, &quot;http://example.org&quot;, fn, NULL);
</code></pre>
<h3 id="mg_send">mg_send()</h3>
<pre><code class="language-c">int mg_send(struct mg_connection *c, const void *data, size_t size);
</code></pre>
<p>Append <code>data</code> of size <code>size</code> to the <code>c-&gt;send</code> buffer. Return number of bytes
appended.</p>
<p>Note: This function does not push data to the network. It only appends data to
the output buffer.  The data is being sent when <code>mg_mgr_poll()</code> is called. If
<code>mg_send()</code> is called multiple times, the output buffer grows.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - A connection pointer</li>
<li><code>data</code> - A pointer to data to append to the send buffer</li>
<li><code>size</code> - A data size</li>
</ul>
<p>Return value: <code>true</code> if data appended successfully and <code>false</code> otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_send(c, &quot;hi&quot;, 2);  // Append string &quot;hi&quot; to the output buffer
</code></pre>
<h3 id="mg_wakeup">mg_wakeup()</h3>
<pre><code class="language-c">void mg_wakeup(struct mg_mgr *mgr, unsigned long id, const void *data, size_t size);
</code></pre>
<p>Any thread/task can send <code>data</code>, <code>size</code> to Mongoose manager executing in
another thread. This is the only Mongoose function that can be called from a
different task/thread.  Calling
this function wakes up the event manager and generates an <code>MG_EV_WAKEUP</code> event
in the respective event handler. Call <a href="#mg_wakeup_init">mg_wakeup_init()</a>
in the event manager thread before first using it.</p>
<p>The data could be anything. It could be a structure. Or it could be a pointer.
The receiving connection gets <code>MG_EV_WAKEUP</code>, and gets that data as a chunk
of memory: <code>struct mg_str *data = ev_data</code>. Note that the sent data should be
small, ideally less than 512 bytes. If you need to send a large piece of data,
allocate it and send a pointer instead - see examples below.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - An event manager</li>
<li><code>id</code> - A destination connection ID</li>
<li><code>data</code> - A pointer to data to append to the send buffer</li>
<li><code>size</code> - A data size</li>
</ul>
<p>Usage example:</p>
<p>Sending small data</p>
<pre><code class="language-c">// Sender side:
struct foo foo = {0};                   // Small structure, size &lt; 512 bytes
mg_wakeup(mgr, id, &amp;foo, sizeof(foo));  // Send a structure

// Receiver side:
if (ev == MG_EV_WAKEUP) {
  struct mg_str *data = (struct mg_str *) ev_data;
  struct foo *foo = (struct foo *) data-&gt;buf;
}
</code></pre>
<p>Sending large data. Sender allocates it, receiver deallocates</p>
<pre><code class="language-c">// Sender side:
struct foo *foo = malloc(sizeof(*foo));  // Big structure, allocate it
mg_wakeup(mgr, id, &amp;foo, sizeof(foo));   // Send a pointer to structure

// Receiver side:
if (ev == MG_EV_WAKEUP) {
  struct mg_str *data = (struct mg_str *) ev_data;
  struct foo *foo = * (struct foo **) data-&gt;buf;
  // Do something with foo ...
  free(foo);   // Deallocate foo
}
</code></pre>
<h3 id="mg_wakeup_init">mg_wakeup_init()</h3>
<pre><code class="language-c">void mg_wakeup_init(struct mg_mgr *mgr);
</code></pre>
<p>Initialize the wakeup scheme used by <a href="#mg_wakeup">mg_wakeup()</a></p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - An event manager</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">mg_wakeup_init(&amp;mgr);  // Initialise wakeup socket pai
</code></pre>
<h3 id="mg_printf-mg_vprintf">mg_printf(), mg_vprintf()</h3>
<pre><code class="language-c">int mg_printf(struct mg_connection *, const char *fmt, ...);
int mg_vprintf(struct mg_connection *, const char *fmt, va_list *ap);
</code></pre>
<p>Same as <code>mg_send()</code>, but formats data using <code>printf()</code> semantics. Return
number of bytes appended to the output buffer.</p>
<blockquote>
<p>NOTE: See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a> for the list of supported
format specifiers</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><code>c</code> - a connection pointer</li>
<li><code>fmt</code> - a format string in <code>printf</code> semantics</li>
</ul>
<p>Return value: number of bytes appended to the output buffer.</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_printf(c, &quot;Hello, %s!&quot;, &quot;world&quot;); // Add &quot;Hello, world!&quot; to output buffer
</code></pre>
<h3 id="mg_wrapfd">mg_wrapfd()</h3>
<pre><code class="language-c">struct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,
                                mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Wrap a given file descriptor <code>fd</code> into a connection, and add that connection
to the event manager. An <code>fd</code> descriptor must support <code>send()</code>, <code>recv()</code>,
<code>select()</code> syscalls, and be non-blocking. Mongoose will treat it as a TCP
socket. The <code>c-&gt;rem</code> and <code>c-&gt;loc</code> addresses will be empty.</p>
<p>Parameters:</p>
<ul>
<li><code>fd</code> - A file descriptor to wrap</li>
<li><code>mgr</code> - An event manager</li>
<li><code>fn</code> - A pointer to event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection
structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: Pointer to the created connection or <code>NULL</code> in case of error</p>
<h3 id="mg_hello">mg_hello()</h3>
<pre><code class="language-c">void mg_hello(const char *url);
</code></pre>
<p>A convenience function that starts a simple web server on a given listening
URL. This function does not return until a &quot;/quit&quot; request is received. A
server handles the following URIs:</p>
<ul>
<li><code>/quit</code> - quit the server, and exit the function</li>
<li><code>/debug</code> - set debug level, expect <code>{&quot;level&quot;: 3}</code> as a POST payload</li>
<li>For all other URIs, <code>hi</code> is returned as a response</li>
</ul>
<p>Parameters:</p>
<ul>
<li><code>url</code> - a listening URL, for example <code>http://0.0.0.0:8000</code></li>
</ul>
<h2 id="http-1">HTTP</h2>
<h3 id="struct-mg_http_header">struct mg_http_header</h3>
<pre><code class="language-c">struct mg_http_header {
  struct mg_str name;   // Header name
  struct mg_str value;  // Header value
};
</code></pre>
<p>Structure represents HTTP header, like <code>Content-Type: text/html</code>.
<code>Content-Type</code> is a header name and <code>text/html</code> is a header value.</p>
<h3 id="struct-mg_http_message">struct mg_http_message</h3>
<pre><code class="language-c">struct mg_http_message {
  struct mg_str method, uri, query, proto;             // Request/response line
  struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers
  struct mg_str body;                                  // Body
  struct mg_str message;                               // Request line + headers + body
};
</code></pre>
<p>Structure represents the HTTP message.</p>
<img src="images/mg_http_message.svg" alt="HTTP message" />

<h3 id="mg_http_listen">mg_http_listen()</h3>
<pre><code class="language-c">struct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,
                                     mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Create HTTP listener.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - An event manager</li>
<li><code>url</code> - A URL, specifies local IP address and port to listen on, e.g. <code>http://0.0.0.0:8000</code>. If this URL is &#39;https&#39;, the <code>is_tls</code> flag will be set</li>
<li><code>fn</code> - An event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: Pointer to created connection or <code>NULL</code> in case of error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_connection *c = mg_http_listen(&amp;mgr, &quot;0.0.0.0:8000&quot;, fn, arg);
if (c == NULL) fatal_error(&quot;Cannot create listener&quot;);
</code></pre>
<h3 id="mg_http_connect">mg_http_connect()</h3>
<pre><code class="language-c">struct mg_connection *mg_http_connect(struct mg_mgr *, const char *url,
                                      mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Create HTTP client connection.</p>
<p>Note: This function does not connect to peer; it allocates required resources and
starts connect process. Once peer is really connected <code>MG_EV_CONNECT</code> event is
sent to connection event handler.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - An event manager</li>
<li><code>url</code> - A URL, specifies remote URL, e.g. <code>http://google.com</code>. If this URL is &#39;https&#39;, the <code>is_tls</code> flag will be set</li>
<li><code>fn</code> - An event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: Pointer to created connection or <code>NULL</code> in case of error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_connection *c = mg_http_connect(&amp;mgr, &quot;http://google.com&quot;, fn, NULL);
if (c == NULL) fatal_error(&quot;Cannot create connection&quot;);
</code></pre>
<h3 id="mg_http_status">mg_http_status()</h3>
<pre><code class="language-c">int mg_http_status(const struct mg_http_message *hm);
</code></pre>
<p>Get status code of the HTTP response.
Parameters:</p>
<ul>
<li><code>hm</code> - Parsed HTTP response</li>
</ul>
<p>Return value: status code, e.g. <code>200</code> for success.</p>
<h3 id="mg_http_get_request_len">mg_http_get_request_len()</h3>
<pre><code class="language-c">int mg_http_get_request_len(const unsigned char *buf, size_t buf_len);
</code></pre>
<p>Get length of request.</p>
<p>The length of request is a number of bytes till the end of HTTP headers. It does
not include length of HTTP body.</p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - A pointer to a buffer with request</li>
<li><code>buf_len</code> - Buffer length</li>
</ul>
<p>Return value: -1 on error, 0 if a message is incomplete, or the length of request</p>
<p>Usage example:</p>
<pre><code class="language-c">const char *buf = &quot;GET /test \n\nGET /foo\n\n&quot;;
int req_len = mg_http_get_request_len(buf, strlen(buf));  // req_len == 12
</code></pre>
<img src="images/mg_http_get_request_len.svg" alt="Function mg_http_get_request_len()" />

<h3 id="mg_http_parse">mg_http_parse()</h3>
<pre><code class="language-c">int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm);
</code></pre>
<p>Parse string request into <code>mg_http_message</code> structure</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - A request string</li>
<li><code>len</code> - A request string length</li>
<li><code>hm</code> - A pointer to a structure to store parsed request</li>
</ul>
<p>Return value: request length (see <code>mg_http_get_request_len()</code>)</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_http_message hm;
const char *buf = &quot;GET / HTTP/1.0\n\n&quot;;
if (mg_http_parse(buf, strlen(buf), &amp;hm) &gt; 0) { /* success */ }
</code></pre>
<h3 id="mg_http_printf_chunk">mg_http_printf_chunk()</h3>
<pre><code class="language-c">void mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...);
</code></pre>
<p>Write a chunk of data in chunked encoding format, using <code>printf()</code> semantic.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - A connection pointer</li>
<li><code>fmt</code> - A string, format specified in <code>printf</code> semantics</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_http_printf_chunk(c, &quot;Hello, %s!&quot;, &quot;world&quot;);
</code></pre>
<h3 id="mg_http_write_chunk">mg_http_write_chunk()</h3>
<pre><code class="language-c">void mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len);
</code></pre>
<p>Write a chunk of data in chunked encoding format.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - A connection pointer</li>
<li><code>buf</code> - Data to write</li>
<li><code>len</code> - Data length</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_http_write_chunk(c, &quot;hi&quot;, 2);
</code></pre>
<h3 id="struct-mg_http_serve_opts">struct mg_http_serve_opts</h3>
<pre><code class="language-c">struct mg_http_serve_opts {
  const char *root_dir;       // Web root directory, must be non-NULL
  const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml
  const char *extra_headers;  // Extra HTTP headers to add in responses
  const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..
  const char *page404;        // Path to the 404 page, or NULL by default
  struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX
};
</code></pre>
<p>A structure passed to <code>mg_http_serve_dir()</code> and <code>mg_http_serve_file()</code>, which
drives the behavior of those two functions.</p>
<p>In addition to overwriting autodetection based on an extension, you can also use <code>*</code> as an extension in <code>mime_types</code> to force a particular MIME type for unknown extensions:</p>
<pre><code class="language-c">sopts.mime_types = &quot;*=preferred/default,txt=override/text&quot;
</code></pre>
<h3 id="mg_http_serve_dir">mg_http_serve_dir()</h3>
<pre><code class="language-c">void mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,
                       const struct mg_http_serve_opts *opts);
</code></pre>
<p>Serve static files according to the given options. Files can also be gzip compressed, including the directory index. All compressed files must end in <code>.gz</code> and there must not exist a file with the same name without the extension, otherwise it will take precedence; see <a href="#mg_http_serve_file">mg_http_serve_file()</a></p>
<blockquote>
<p>NOTE: In order to enable SSI, you need to set the <code>-DMG_ENABLE_SSI=1</code> build
flag.</p>
</blockquote>
<blockquote>
<p>NOTE:  Avoid double dots <code>..</code> in the <code>root_dir</code>. If you need to reference an
upper-level directory, use an absolute path.</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>hm</code> - HTTP message, that should be served</li>
<li><code>opts</code> - Serve options. Note that <code>opts.root_dir</code> can optionally accept
extra comma-separated <code>uri=path</code> pairs, see example below</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose events handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    struct mg_http_serve_opts opts;
    memset(&amp;opts, 0, sizeof(opts));
    opts.root_dir = &quot;/var/www,/conf=/etc&quot;;  // Serve /var/www. URIs starting with /conf are served from /etc
    mg_http_serve_dir(c, hm, &amp;opts);
  }
}
</code></pre>
<h3 id="mg_http_serve_file">mg_http_serve_file()</h3>
<pre><code class="language-c">void mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,
                        const char *path, struct mg_http_serve_opts *opts);
</code></pre>
<p>Serve a static file. If a file with the filename specified in <code>path</code> does not exist, Mongoose tries appending <code>.gz</code>; and if such a file exists, it will serve it with a <code>Content-Encoding: gzip</code> header </p>
<blockquote>
<p>NOTE: <code>opts-&gt;root_dir</code> settings is ignored by this function.</p>
</blockquote>
<blockquote>
<p>NOTE:  <code>opts-&gt;extra_headers</code>, if not NULL, must end with <code>\r\n</code>.</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>hm</code> - HTTP message to serve</li>
<li><code>path</code> - Path to file to serve</li>
<li><code>opts</code> - Serve options</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose events handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    struct mg_http_serve_opts opts = {
      .mime_types = &quot;png=image/png&quot;,
      .extra_headers = &quot;AA: bb\r\nCC: dd\r\n&quot;
    };
    mg_http_serve_file(c, hm, &quot;a.png&quot;, &amp;opts);
  }
}
</code></pre>
<h3 id="mg_http_reply">mg_http_reply()</h3>
<pre><code class="language-c">void mg_http_reply(struct mg_connection *c, int status_code,
                   const char *headers, const char *body_fmt, ...);
</code></pre>
<p>Send simple HTTP response using <code>printf()</code> semantic. This function formats
response body according to a <code>body_fmt</code>, and automatically appends a correct
<code>Content-Length</code> header. Extra headers could be passed via <code>headers</code> parameter.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>status_code</code> - An HTTP response code</li>
<li><code>headers</code> - Extra headers, default NULL. If not NULL, must end with <code>\r\n</code></li>
<li><code>fmt</code> - A format string for the HTTP body, in a printf semantics</li>
</ul>
<p>Return value: None</p>
<img src="images/mg_http_reply.svg" alt="Function mg_http_reply()" />

<p>Usage examples:</p>
<p>Send a simple JSON response:</p>
<pre><code class="language-c">mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;, &quot;{\&quot;result\&quot;: %d}&quot;, 123);
</code></pre>
<p>Send JSON response:</p>
<pre><code class="language-c">char *json = mg_mprintf(&quot;{%m:%d}&quot;, MG_ESC(&quot;name&quot;), 123);
mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;, &quot;%s\n&quot;, json);
mg_free(json);
</code></pre>
<p>Send a 302 redirect:</p>
<pre><code class="language-c">mg_http_reply(c, 302, &quot;Location: /\r\n&quot;, &quot;&quot;);
</code></pre>
<p>Send error:</p>
<pre><code class="language-c">mg_http_reply(c, 403, &quot;&quot;, &quot;%s&quot;, &quot;Not Authorized\n&quot;);
</code></pre>
<h3 id="mg_http_get_header">mg_http_get_header()</h3>
<pre><code class="language-c">struct mg_str *mg_http_get_header(struct mg_http_message *hm, const char *name);
</code></pre>
<p>Get HTTP header value</p>
<p>Parameters:</p>
<ul>
<li><code>hm</code> - HTTP message to look for header</li>
<li><code>name</code> - Header name</li>
</ul>
<p>Return value: HTTP header value or <code>NULL</code> if not found</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose event handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    struct mg_str *s = mg_http_get_header(hm, &quot;X-Extra-Header&quot;);
    if (s != NULL) {
      mg_http_reply(c, 200, &quot;&quot;, &quot;Holly molly! Header value: %.*s&quot;, (int) s-&gt;len, s-&gt;buf);
    } else {
      mg_http_reply(c, 200, &quot;&quot;, &quot;Oh no, header is not set...&quot;);
    }
  }
}
</code></pre>
<h3 id="mg_http_get_header_var">mg_http_get_header_var()</h3>
<pre><code class="language-c">struct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);
</code></pre>
<p>Parse HTTP header (e.g. Cookie header) which has form
<code>name1=value1; name2=value2; ...</code> and fetch a given variable.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - HTTP header</li>
<li><code>name</code> - variable name name</li>
</ul>
<p>Return value: a requested variable, or an empty string.</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str *cookie = mg_http_get_header(hm, &quot;Cookie&quot;);
struct mg_str token = mg_str(&quot;&quot;);

if (cookie != NULL) {
  token = mg_http_get_header_var(*cookie, mg_str(&quot;access_token&quot;));
}
</code></pre>
<h3 id="mg_http_var">mg_http_var()</h3>
<pre><code class="language-c">struct mg_str mg_http_var(struct mg_str buf, struct mg_str name);
</code></pre>
<p>Fetch an undecoded HTTP variable. Parameters:</p>
<ul>
<li><code>buf</code> - a url-encoded string: HTTP request body or query string</li>
<li><code>name</code> - a variable name to fetch</li>
</ul>
<p>Return value: variable&#39;s value. If not found, it is a NULL string.</p>
<pre><code class="language-c">// We have received a request to /my/uri?a=b&amp;c=d%20
// The hm-&gt;query points to &quot;a=b&amp;c=d%20&quot;
struct mg_str v = mg_http_var(hm-&gt;query, mg_str(&quot;c&quot;));  // v = &quot;d%20&quot;
</code></pre>
<h3 id="mg_http_get_var">mg_http_get_var()</h3>
<pre><code class="language-c">int mg_http_get_var(const struct mg_str *var, const char *name, char *buf, int len);
</code></pre>
<p>Fetch and decode an HTTP variable</p>
<p>Parameters:</p>
<ul>
<li><code>var</code> - HTTP request body</li>
<li><code>name</code> - Variable name</li>
<li><code>buf</code> - Buffer to write decoded variable</li>
<li><code>len</code> - Buffer size</li>
</ul>
<p>Return value: Length of decoded variable. A zero or negative value means error</p>
<p>Usage example:</p>
<pre><code class="language-c">char buf[100] = &quot;&quot;;
mg_http_get_var(&amp;hm-&gt;body, &quot;key1&quot;, buf, sizeof(buf)) {
  ...
}
</code></pre>
<h3 id="mg_http_creds">mg_http_creds()</h3>
<pre><code class="language-c">void mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,
                   char *pass, size_t passlen);
</code></pre>
<p>Fetch authentication credential from the request, and store into the
<code>user</code>, <code>userlen</code> and <code>pass</code>, <code>passlen</code> buffers. The credentials are looked
up in the following order:</p>
<ul>
<li>from the <code>Authorization</code> HTTP header,<ul>
<li>Basic auth fills both user and pass</li>
<li>Bearer auth fills only pass</li>
</ul>
</li>
<li>from the <code>access_token</code> cookie, fills pass</li>
<li>from the <code>?access_token=...</code> query string parameter, fills pass</li>
</ul>
<p>If none is found, then both user and pass are set to empty nul-terminated strings.</p>
<p>Parameters:</p>
<ul>
<li><code>hm</code> - HTTP message to look for credentials</li>
<li><code>user</code> - buffer to receive user name</li>
<li><code>userlen</code> - size of <code>user</code> buffer</li>
<li><code>pass</code> - buffer to receive password</li>
<li><code>passlen</code> - size of <code>pass</code> buffer</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose events handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    char user[100], pass[100];
    mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass)); // &quot;user&quot; is now user name and &quot;pass&quot; is now password from request
  }
}
</code></pre>
<h3 id="mg_http_bauth">mg_http_bauth()</h3>
<pre><code class="language-c">void mg_http_bauth(struct mg_connection *c, const char *user, const char *pass);
</code></pre>
<p>Write a Basic <code>Authorization</code> header to the output buffer.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>user</code> - User name</li>
<li><code>pass</code> - Password</li>
</ul>
<p>Return value: None</p>
<p>Usage example which uses Basic auth to create Stripe subscription:</p>
<pre><code class="language-c">  mg_printf(c, &quot;POST /v1/subscriptions HTTP/1.1\r\n&quot;
               &quot;Host: api.stripe.com\r\n&quot;
               &quot;Transfer-Encoding: chunked\r\n&quot;);
  mg_http_bauth(c, stripe_private_key, NULL);     // Add Basic auth header
  mg_printf(c, &quot;%s&quot;, &quot;\r\n&quot;);                     // End HTTP headers

  mg_http_printf_chunk(c, &quot;&amp;customer=%s&quot;, customer_id);   // Set customer
  mg_http_printf_chunk(c, &quot;&amp;items[0][price]=%s&quot;, price);  // And price
  mg_http_printf_chunk(c, &quot;&quot;);                            // End request
</code></pre>
<h3 id="struct-mg_http_part">struct mg_http_part</h3>
<pre><code class="language-c">// Parameter for mg_http_next_multipart
struct mg_http_part {
  struct mg_str name;      // Form field name
  struct mg_str filename;  // Filename for file uploads
  struct mg_str body;      // Part contents
};
</code></pre>
<p>Structure that describes a single part of a HTTP multipart message.</p>
<img src="images/mg_http_part.svg" alt="HTTP part" />

<h3 id="mg_http_next_multipart">mg_http_next_multipart()</h3>
<pre><code class="language-c">size_t mg_http_next_multipart(struct mg_str body, size_t offset, struct mg_http_part *part);
</code></pre>
<p>Parse the multipart chunk in the <code>body</code> at a given <code>offset</code>. An initial
<code>offset</code> should be 0. Fill up parameters in the provided <code>part</code>, which could be
NULL. Return offset to the next chunk, or 0 if there are no more chunks.</p>
<p>Parameters:</p>
<ul>
<li><code>body</code>- Message body</li>
<li><code>offset</code> - Start offset</li>
<li><code>part</code> - Pointer to <code>struct mg_http_part</code> to fill</li>
</ul>
<p>Return value: offset to the next chunk, or 0 if there are no more chunks.</p>
<p>Usage example (or see <a href="tutorials/http/file-uploads/">form upload tutorial</a> ):</p>
<pre><code class="language-c">struct mg_http_part part;
size_t pos = 0;

while ((pos = mg_http_next_multipart(body, pos, &amp;part)) != 0) {
  MG_INFO((&quot;Chunk name: [%.*s] filename: [%.*s] length: %lu bytes&quot;,
           part.name.len, part.name.buf,
           part.filename.len, part.filename.buf, part.body.len));
  // Use this chunk ....
}
</code></pre>
<p>A diagram below shows how <code>mg_http_next_multipart()</code> in action:</p>
<img src="images/mg_http_next_multipart.svg" alt="Function mg_http_next_multipart()" />

<h3 id="mg_http_upload">mg_http_upload()</h3>
<pre><code class="language-c">
long mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,
                    struct mg_fs *fs, const char *dir, size_t max_size);
</code></pre>
<p>This is a helper utility function that is used to upload large files by small
chunks.</p>
<p>Append HTTP POST data to a file in a specified directory.  A file name and
file offset are specified by the query string parameters:
<code>POST /upload?file=firmware.bin&amp;offset=2048 HTTP/1.1</code>. If the offset is 0, then the
file is truncated. It is the client&#39;s responsibility to divide files into 
smaller chunks and send a sequence of POST requests that will be handled by
this function. The full path will be checked for sanity</p>
<p>Parameters:</p>
<ul>
<li><code>c</code>- a connection</li>
<li><code>hm</code> - a parsed HTTP message</li>
<li><code>fs</code> - a filesystem where to write the files, e.g. <code>&amp;mg_fs_posix</code></li>
<li><code>dir</code> - a directory path where to write the files</li>
<li><code>max_size</code> - maximum allowed file size</li>
</ul>
<p>Return value: file size after write, or negative number on error</p>
<p>Usage example:</p>
<pre><code class="language-c">static void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    if (mg_match(hm-&gt;uri, mg_str(&quot;/upload&quot;), NULL)) {
      mg_http_upload(c, hm, &amp;mg_fs_posix, &quot;/tmp&quot;, 99999);
    } else {
      struct mg_http_serve_opts opts = {.root_dir = &quot;.&quot;};   // Serve
      mg_http_serve_dir(c, ev_data, &amp;opts);                 // static content
    }
  }
}
</code></pre>
<h2 id="websocket-1">WebSocket</h2>
<h3 id="struct-mg_ws_message">struct mg_ws_message</h3>
<pre><code class="language-c">struct mg_ws_message {
  struct mg_str data; // WebSocket message data
  uint8_t flags;      // WebSocket message flags
};
</code></pre>
<p>This structure represents the WebSocket message, the <code>flags</code> element
corresponds to the first byte as described in <a href="https://www.rfc-editor.org/rfc/rfc6455#section-5.2">RFC 6455 section
5.2</a>.</p>
<p>To extract the message type from an incoming message, check the four LSBs in
the <code>flags</code> element of the <code>struct mg_ws_message</code>.</p>
<p>Possible WebSocket message types:</p>
<pre><code class="language-c">#define WEBSOCKET_OP_CONTINUE 0
#define WEBSOCKET_OP_TEXT 1
#define WEBSOCKET_OP_BINARY 2
#define WEBSOCKET_OP_CLOSE 8
#define WEBSOCKET_OP_PING 9
#define WEBSOCKET_OP_PONG 10
</code></pre>
<pre><code class="language-c">// Mongoose events handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_WS_MSG) {
    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;
    msgtype = wm-&gt;flags &amp; 0x0F;
    if (msgtype == WEBSOCKET_OP_BINARY) {
      // This is a binary data message
    } else if (msgtype == WEBSOCKET_OP_TEXT) {
      // This is a text data message
    }
  }
}
</code></pre>
<p>To send a message, use the proper message type as described in <a href="https://www.rfc-editor.org/rfc/rfc6455#section-5.6">RFC 6455 section 5.6</a> for data frames. when calling <a href="#mg_ws_send">mg_ws_send()</a> or <a href="#mg_ws_printf-mg_ws_vprintf">mg_ws_printf()</a> below</p>
<h3 id="mg_ws_connect">mg_ws_connect()</h3>
<pre><code class="language-c">struct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url,
                                    mg_event_handler_t fn, void *fn_data,
                                    const char *fmt, ...);
</code></pre>
<p>Create client WebSocket connection.</p>
<p>Note: this function does not connect to peer, it allocates required resources and
 starts the connect process. Once peer is really connected, the <code>MG_EV_CONNECT</code> event is
 sent to connection event handler.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - Event manager to use</li>
<li><code>url</code> - Specifies remote URL, e.g. <code>http://google.com</code>. If this URL is &#39;wss&#39;, the <code>is_tls</code> flag will be set</li>
<li><code>fn</code> - An event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics for additional HTTP headers, or NULL. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: Pointer to created connection or <code>NULL</code> on error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_connection *c = mg_ws_connect(&amp;mgr, &quot;ws://test_ws_server.com:1000&quot;,
                                        handler, NULL, &quot;%s&quot;, &quot;Sec-WebSocket-Protocol: echo\r\n&quot;);
if(c == NULL) fatal(&quot;Cannot create connection&quot;);
</code></pre>
<h3 id="mg_ws_upgrade">mg_ws_upgrade()</h3>
<pre><code class="language-c">void mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *,
                   const char *fmt, ...);
</code></pre>
<p>Upgrade given HTTP connection to WebSocket. Parameter <code>fmt</code> is a printf-like
format string for the extra HTTP headers returned to the client in a
WebSocket handshake. Set it to <code>NULL</code> if no extra headers need to be passed.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>hm</code> - HTTP message</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics for additional HTTP headers, or NULL. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose events handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_HTTP_MSG) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    mg_ws_upgrade(c, hm, NULL);  // Upgrade HTTP to WS
  }
}
</code></pre>
<h3 id="mg_ws_send">mg_ws_send()</h3>
<pre><code class="language-c">size_t mg_ws_send(struct mg_connection *c, const void *buf, size_t len, int op);
</code></pre>
<p>Send data to WebSocket peer</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>buf</code> - Data to send</li>
<li><code>len</code> - Data size</li>
<li><code>op</code> - WebSocket message type, see <a href="#websocket-message-type">WebSocket message type</a> above</li>
</ul>
<p>Return value: sent bytes count</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose events handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_WS_OPEN) {
    struct mg_http_message *hm = (struct mg_http_message *) ev_data;
    mg_ws_send(c, &quot;opened&quot;, 6, WEBSOCKET_OP_BINARY);  // Send &quot;opened&quot; to web socket connection
  }
}
</code></pre>
<h3 id="mg_ws_printf-mg_ws_vprintf">mg_ws_printf(), mg_ws_vprintf()</h3>
<pre><code class="language-c">size_t mg_ws_printf(struct mg_connection *, int op, const char *fmt, ...);
size_t mg_ws_vprintf(struct mg_connection *, int op, const char *fmt, va_list *);
</code></pre>
<p>Same as <code>mg_ws_send()</code>, but formats data using <code>printf()</code> semantics.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>op</code> - WebSocket message type, see <a href="#websocket-message-type">WebSocket message type</a> above</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: sent bytes count</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_ws_printf(c, WEBSOCKET_OP_TEXT, &quot;Hello, %s!&quot;, &quot;world&quot;);
</code></pre>
<h3 id="mg_ws_wrap">mg_ws_wrap()</h3>
<pre><code class="language-c">size_t mg_ws_wrap(struct mg_connection *c, size_t len, int op)
</code></pre>
<p>Convert data in output buffer to WebSocket format. Useful when implementing a protocol over WebSocket
See <a href="https://github.com/cesanta/mongoose/tree/master/tutorials/mqtt/mqtt-over-ws-client">tutorials/mqtt/mqtt-over-ws-client</a> for a full example.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>len</code> - Bytes count to convert</li>
<li><code>op</code> - Websocket message type (see <code>mg_ws_send</code>)</li>
</ul>
<p>Return value: New size of connection output buffer</p>
<p>Usage example:</p>
<pre><code class="language-c">size_t len = c-&gt;send.len;         // Store output buffer len
mg_mqtt_login(c, s_url, &amp;opts);   // Write MQTT login message
mg_ws_wrap(c, c-&gt;send.len - len, WEBSOCKET_OP_BINARY); // Wrap it into WS
</code></pre>
<h2 id="sntp">SNTP</h2>
<h3 id="mg_sntp_connect">mg_sntp_connect()</h3>
<pre><code class="language-c">struct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,
                                      mg_event_handler_t fn, void *fn_data)
</code></pre>
<p>Connect to an SNTP server.</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - Event manager to use</li>
<li><code>url</code> - Specifies remote URL, <code>time.google.com</code> if NULL.</li>
<li><code>fn</code> - A user event handler function, use NULL if you don&#39;t need one</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection
structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: Pointer to created connection or <code>NULL</code> on error</p>
<p>Simplest usage example: see <a href="#mg_now">mg_now()</a></p>
<p>Full usage example:</p>
<pre><code class="language-c">static void sntp_cb(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_SNTP_TIME) {
    // Time received, the internal protocol handler updates what mg_now() returns
    uint64_t curtime = mg_now();
    // otherwise, you can process the server returned data yourself
    uint64_t epoch_millis = *(uint64_t *) ev_data;
  }
}
...
mg_sntp_connect(mgr&amp;, NULL /* connect to time.google.com */, sntp_cb, NULL);
</code></pre>
<h3 id="mg_sntp_request">mg_sntp_request()</h3>
<pre><code class="language-c">void mg_sntp_request(struct mg_connection *c)
</code></pre>
<p>Send time request to SNTP server</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_sntp_request(c);
</code></pre>
<h2 id="mqtt-1">MQTT</h2>
<h3 id="struct-mg_mqtt_opts">struct mg_mqtt_opts</h3>
<pre><code class="language-c">struct mg_mqtt_opts {
  struct mg_str user;               // Username, can be empty
  struct mg_str pass;               // Password, can be empty
  struct mg_str client_id;          // Client ID
  struct mg_str topic;              // message/subscription topic
  struct mg_str message;            // message content
  uint8_t qos;                      // message quality of service
  uint8_t version;                  // Can be 4 (3.1.1), or 5. If 0, assume 4
  uint16_t keepalive;               // Keep-alive timer in seconds
  uint16_t retransmit_id;           // For PUBLISH, init to 0
  bool retain;                      // Retain flag
  bool clean;                       // Clean session flag
  struct mg_mqtt_prop *props;       // MQTT5 props array
  size_t num_props;                 // number of props
  struct mg_mqtt_prop *will_props;  // Valid only for CONNECT packet (MQTT5)
  size_t num_will_props;            // Number of will props
};
</code></pre>
<p>Structure used when connecting to a broker and when sending messages, to specify connection options and last-will message or to specify message and options</p>
<h3 id="struct-mg_mqtt_message">struct mg_mqtt_message</h3>
<pre><code class="language-c">struct mg_mqtt_message {
  struct mg_str topic;  // Parsed topic for PUBLISH
  struct mg_str data;   // Parsed message for PUBLISH
  struct mg_str dgram;  // Whole MQTT packet, including headers
  uint16_t id;          // For PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, PUBLISH
  uint8_t cmd;          // MQTT command, one of MQTT_CMD_*
  uint8_t qos;          // Quality of service
  uint8_t ack;          // CONNACK return code, 0 = success
  size_t props_start;   // Offset to the start of the properties (MQTT5)
  size_t props_size;    // Length of the properties
};
</code></pre>
<p>Structure representing an MQTT packet, either control or data</p>
<h3 id="mg_mqtt_connect">mg_mqtt_connect()</h3>
<pre><code class="language-c">struct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,
                                      const struct mg_mqtt_opts *opts,
                                      mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Create a client MQTT connection</p>
<p>Note: This function does not connect to a broker; it allocates the required resources and
starts the TCP connection process. Once that connection is established, an <code>MG_EV_CONNECT</code> event is
sent to the connection event handler, then the MQTT connection process is started (by means of <a href="#mg_mqtt_login">mg_mqtt_login()</a>); and once the MQTT connection request gets a response from the broker, an <code>MG_EV_MQTT_OPEN</code> event is sent to the connection event handler; connection results are inside a <a href="#struct-mg_mqtt_message">struct mg_mqtt_message</a></p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - Event manager to use</li>
<li><code>url</code> - Specifies the broker URL, e.g. <code>mqtt://cloud.hivemq.com</code>. If this URL is &#39;mqtts&#39;, the <code>is_tls</code> flag will be set</li>
<li><code>opts</code> - pointer to <a href="#struct-mg_mqtt_opts">MQTT options</a> like client ID, clean session, last will, etc. Can be NULL</li>
<li><code>fn</code> - The event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: pointer to the created connection or <code>NULL</code> on error</p>
<p>Usage example:</p>
<pre><code class="language-c">void fn(struct mg_connection *c, int ev, void *evd, void *fnd) {
  if (ev == MG_EV_CONNECT) {
    // TCP connection succeeded,
    // If target URL is TLS, set it up
  } else if (ev == MG_EV_MQTT_OPEN) {
    // MQTT connection process finished
    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) ev_data;
    if(mm-&gt;ack)  // MQTT connection succeeded
  }
}
</code></pre>
<pre><code class="language-c">mg_mqtt_connect(&amp;mgr, &quot;mqtt://test.org:1883&quot;, NULL, fn, NULL);
</code></pre>
<p>or</p>
<pre><code class="language-c">struct mg_mqtt_opts opts = {.qos = 1,
                            .retain = true,
                            .topic = mg_str(&quot;mytopic&quot;),
                            .message = mg_str(&quot;goodbye&quot;)};
mg_mqtt_connect(&amp;mgr, &quot;mqtt://test.org:1883&quot;, &amp;opts, fn, NULL);
</code></pre>
<h3 id="mg_mqtt_listen">mg_mqtt_listen()</h3>
<pre><code class="language-c">struct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,
                                     mg_event_handler_t fn, void *fn_data);
</code></pre>
<p>Create an MQTT listener (act like a broker).</p>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - Event manager to use</li>
<li><code>url</code> - Specifies the local IP address and port to listen on, e.g. <code>mqtt://0.0.0.0:1883</code>. If this URL is &#39;mqtts&#39;, the <code>is_tls</code> flag will be set</li>
<li><code>fn</code> - The event handler function</li>
<li><code>fn_data</code> - an arbitrary pointer, which will be stored in the connection structure as <code>c-&gt;fn_data</code>, so the event handler can use it when called.</li>
</ul>
<p>Return value: Pointer to the created connection or <code>NULL</code> on error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_connection *c = mg_mqtt_listen(&amp;mgr, &quot;mqtt://0.0.0.0:1883&quot;, fn, arg);
if (c == NULL) return -1; // Could not create connection
</code></pre>
<h3 id="mg_mqtt_login">mg_mqtt_login()</h3>
<pre><code class="language-c">void mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts);
</code></pre>
<p>Send MQTT CONNECT request. Once the MQTT connection request gets a response from the broker, an <code>MG_EV_MQTT_OPEN</code> event is sent to the connection event handler.
This function is usually called by <a href="#mg_mqtt_connect">mg_mqtt_connect()</a>, you will only need to call it when you manually start the MQTT connect process, e.g: when using MQTT over WebSocket. Connection results are inside a <a href="#struct-mg_mqtt_message">struct mg_mqtt_message</a></p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>opts</code> - pointer to <a href="#struct-mg_mqtt_opts">MQTT connect options</a>, containing user name and password to use, if any, and other options</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose event handler
void fn(struct mg_connection *c, int ev, void *evd, void *fnd) {
  if (ev == MG_EV_WS_OPEN) {
    // WS connection established. Perform MQTT login
    struct mg_mqtt_opts opts = {.qos = 1,
                                .retain = true,
                                .topic = mg_str(&quot;mytopic&quot;),
                                .message = mg_str(&quot;goodbye&quot;)};
    mg_mqtt_login(c, &amp;opts);
  } else if (ev == MG_EV_MQTT_OPEN) {
    // MQTT connection process finished
    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) ev_data;
    if(mm-&gt;ack)  // MQTT connection succeeded
  }
}
</code></pre>
<h3 id="mg_mqtt_pub">mg_mqtt_pub()</h3>
<pre><code class="language-c">uint16_t mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts);
</code></pre>
<p>Publish a message to a specified topic, each contained in a <code>struct msg_str</code></p>
<p>Note: This function does not actually send the message, it delivers to the underlying TCP/IP stack which will be checked later when the manager runs.</p>
<p>Note that Mongoose does not handle retries for QoS 1 and 2. That has to be handled by the application in the event handler, if needed. You can check if a publish request with QoS 1 or 2 succeeded by catching <code>MG_EV_MQTT_CMD</code> events and checking for reception of PUBACK/PUBREC and PUBCOMP messsages; and their result codes inside a <code>struct mg_mqtt_message</code></p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>opts</code> - pointer to publish <a href="#struct-mg_mqtt_opts">MQTT options</a>, like QoS, and retain flag. The message body is expected at <code>opts-&gt;message</code>, the topic at <code>opts-&gt;topic</code>; both as <a href="#struct-mg_str">mg_str</a></li>
</ul>
<p>Return value: When using QoS other than 0, this function returns the <code>id</code> field sent to the broker, suitable to be held in <code>opts-&gt;retransmit_id</code> for a possible retransmission. See <a href="https://mongoose.ws/documentation/tutorials/mqtt/mqtt-client/#sending-qos-1-messages">this tutorial</a>. Discard the returned value if not interested in doing retransmissions, and initialize <code>opts-&gt;retransmit_id</code> as <code>0</code>.</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_mqtt_opts pub_opts = {.topic = mg_str(&quot;mytopic&quot;),
                                .message = mg_str(&quot;hello&quot;),
                                .qos = 1,
                                .retain = false};
mg_mqtt_pub(c, &amp;pub_opts);
</code></pre>
<h3 id="mg_mqtt_sub">mg_mqtt_sub()</h3>
<pre><code class="language-c">void mg_mqtt_sub(struct mg_connection *, const struct mg_mqtt_opts *opts);
</code></pre>
<p>Subscribe to a topic specified as a <code>struct msg_str</code>. You can check if a subscription request succeeded by catching <code>MG_EV_MQTT_CMD</code> events and checking for reception of a PUBACK messsage and its result code inside the <code>struct mg_mqtt_message</code></p>
<p>Reception of a message will trigger an <code>MG_EV_MQTT_MSG</code> event providing a <a href="#struct-mg_mqtt_message">struct mg_mqtt_message</a>. Note that Mongoose does not handle broker retries for QoS 2 and duplicated messages have to be handled by the application in the event handler, if required</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>opts</code> - pointer to subscription <a href="#struct-mg_mqtt_opts">MQTT options</a>, like QoS. The topic is expected at <code>opts-&gt;topic</code> as an <a href="#struct-mg_str">mg_str</a></li>
</ul>
<p>Return value: None</p>
<pre><code class="language-c">// Mongoose event handler
void fn(struct mg_connection *c, int ev, void *evd, void *fnd) {
  if (ev == MG_EV_MQTT_MSG) {
    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) ev_data;
    MG_INFO((&quot;%.*s\t%.*s&quot;, (int) mm-&gt;topic.len, mm-&gt;topic.buf),
             (int) mm-&gt;data.len, mm-&gt;data.buf);
  }
}

struct mg_mqtt_opts sub_opts = {.topic = mg_str(&quot;mytopic&quot;),
                                .qos = 1};
mg_mqtt_sub(c, &amp;sub_opts);
</code></pre>
<h3 id="mg_mqtt_send_header">mg_mqtt_send_header()</h3>
<pre><code class="language-c">void mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags, uint32_t len);
</code></pre>
<p>Send an MQTT command header. Useful in handling QoS 2 and MQTT server implementations. The command can be one of the following:</p>
<pre><code class="language-c">#define MQTT_CMD_CONNECT 1
#define MQTT_CMD_CONNACK 2
#define MQTT_CMD_PUBLISH 3
#define MQTT_CMD_PUBACK 4
#define MQTT_CMD_PUBREC 5
#define MQTT_CMD_PUBREL 6
#define MQTT_CMD_PUBCOMP 7
#define MQTT_CMD_SUBSCRIBE 8
#define MQTT_CMD_SUBACK 9
#define MQTT_CMD_UNSUBSCRIBE 10
#define MQTT_CMD_UNSUBACK 11
#define MQTT_CMD_PINGREQ 12
#define MQTT_CMD_PINGRESP 13
#define MQTT_CMD_DISCONNECT 14
</code></pre>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>cmd</code> - Command (see above)</li>
<li><code>flags</code> - Command flags (see MQTT specs)</li>
<li><code>len</code> - Size of what follows this header</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Mongoose event handler
void fn(struct mg_connection *c, int ev, void *ev_data) {
  if (ev == MG_EV_MQTT_CMD) {
    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) ev_data;
    if (mm-&gt;cmd == MQTT_CMD_CONNECT) {
        uint8_t response[] = {0, 0};
        mg_mqtt_send_header(c, MQTT_CMD_CONNACK, 0, sizeof(response));  // Send acknowledgement
        mg_send(c, response, sizeof(response));
    }
  }
}
</code></pre>
<h3 id="mg_mqtt_ping">mg_mqtt_ping()</h3>
<pre><code class="language-c">void mg_mqtt_ping(struct mg_connection *c);
</code></pre>
<p>Send an <code>MQTT_CMD_PINGREQ</code> command via <a href="#mg_mqtt_send_header">mg_mqtt_send_header()</a></p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// Send periodic pings to all (MQTT over) WS connections
static void timer_fn(void *arg) {
  struct mg_mgr *mgr = (struct mg_mgr *) arg;
  for (struct mg_connection *c = mgr-&gt;conns; c != NULL; c = c-&gt;next) {
    if (c-&gt;is_websocket) mg_mqtt_ping(c);
  }
}
</code></pre>
<h3 id="mg_mqtt_parse">mg_mqtt_parse()</h3>
<pre><code class="language-c">int mg_mqtt_parse(const uint8_t *buf, size_t len, struct mg_mqtt_message *m);
</code></pre>
<p>Parse a buffer and fill an <code>mg_mqtt_message</code> structure if it contains a valid MQTT packet.</p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - buffer with MQTT packet to parse</li>
<li><code>len</code> - buffer length</li>
<li><code>m</code> - pointer to a <a href="#struct-mg_mqtt_message">struct mg_mqtt_message</a> to be filled with the parsed message</li>
</ul>
<p>Return value: <code>MQTT_OK</code> if message is successfully parsed, <code>MQTT_INCOMPLETE</code> if message
isn&#39;t fully received and <code>MQTT_MALFORMED</code> if message has a wrong format.</p>
<p>Usage example:</p>
<pre><code class="language-c">// Iterate over all MQTT frames contained in buf, len
struct mg_mqtt_message mm;
while ((mg_mqtt_parse(buf, len, &amp;mm)) == MQTT_OK) {
  switch (mm.cmd) {
    case MQTT_CMD_CONNACK:
      ...
  }
  buf += mm.dgram.len;
  len -= mm.dgram.len;
}
</code></pre>
<h3 id="mg_mqtt_disconnect">mg_mqtt_disconnect()</h3>
<pre><code class="language-c">void mg_mqtt_disconnect(struct mg_connection *c, const struct mg_mqtt_opts *opts);
</code></pre>
<p>End an client MQTT connection</p>
<p>Note: This function does not destroy a connection; it just sends a disconnect request to the broker. Once the connection is terminated, an <code>MG_EV_CLOSE</code> event will be sent to the connection event handler</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to use</li>
<li><code>opts</code> - pointer to <a href="#struct-mg_mqtt_opts">MQTT options</a>, can be NULL for MQTT 3.1.1 connections</li>
</ul>
<p>Return value: None</p>
<h2 id="tls">TLS</h2>
<h3 id="struct-mg_tls_opts">struct mg_tls_opts</h3>
<pre><code class="language-c">struct mg_tls_opts {
  struct mg_str ca;    // CA certificate; for both listeners and clients. PEM or DER
  struct mg_str cert;  // Certificate. PEM or DER
  struct mg_str key;   // Private key. PEM or DER
  struct mg_str name;  // If not empty, enable server name verification
};
</code></pre>
<p>TLS options structure:</p>
<ul>
<li><code>ca</code> - Certificate Authority, an <a href="#struct-mg_str">mg_str</a>. Used to verify the certificate that the other end sends to us. If NULL, then server authentication for clients and client authentication for servers are disabled</li>
<li><code>cert</code> - Our own certificate; an <a href="#struct-mg_str">mg_str</a>. If NULL, then we don&#39;t authenticate ourselves to the other peer</li>
<li><code>key</code> - Our own private key; an <a href="#struct-mg_str">mg_str</a>. Sometimes, a certificate and its key are bundled in a single PEM file, in which case the values for <code>cert</code> and <code>key</code> could be the same</li>
<li><code>name</code> - Server name; an <a href="#struct-mg_str">mg_str</a>. If not empty, enable server name verification</li>
</ul>
<blockquote>
<p>NOTE: if both <code>ca</code> and <code>cert</code> are set, then two-way (mutual) TLS authentication is enabled,
both sides authenticate each other. Usually, for one-way (server) TLS authentication,
server connections set both <code>key</code> and <code>cert</code>, whilst clients only <code>ca</code> and/or possibly <code>name</code>.</p>
</blockquote>
<p>For more information on developing TLS clients and servers, and how to load credentials, see the <a href="tutorials/tls/">TLS tutorial</a></p>
<h3 id="mg_tls_init">mg_tls_init()</h3>
<pre><code class="language-c">void mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *);
</code></pre>
<p>Initialise TLS on a given connection.</p>
<blockquote>
<p>NOTE: The mbedTLS implementation uses <code>mg_random</code> as RNG. The <code>mg_random</code> function can be
overridden by setting <code>MG_ENABLE_CUSTOM_RANDOM=1</code> and defining your own <code>mg_random()</code> implementation.</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection, for which TLS should be initialized</li>
<li><code>opts</code> - TLS initialization parameters</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// client event handler:
  if (ev == MG_EV_CONNECT) {
    struct mg_tls_opts opts = {.ca = mg_str(s_tls_ca)};
    mg_tls_init(c, &amp;opts);

// server event handler:
  if (ev == MG_EV_ACCEPT) {
    struct mg_tls_opts opts = {.cert = mg_str(s_tls_cert),
                               .key = mg_str(s_tls_key)};
    mg_tls_init(c, &amp;opts);
</code></pre>
<p>For more information on developing TLS clients and servers, see the <a href="tutorials/tls/">TLS tutorial</a></p>
<h2 id="timer">Timer</h2>
<h3 id="mg_timer_add">mg_timer_add()</h3>
<pre><code class="language-c">struct mg_timer *mg_timer_add(struct mg_mgr *mgr,
                           uint64_t period_ms, unsigned flags,
                           void (*fn)(void *), void *fn_data);
</code></pre>
<p>Setup a timer. This is a high-level timer API that allows to add a software
timer to the event manager. This function <code>mg_calloc()</code>s a new timer and
adds it to the <code>mgr-&gt;timers</code> list. All added timers are polled when
<code>mg_mgr_poll()</code> is called, and called if expired.</p>
<blockquote>
<p>NOTE: Make sure that the timer interval is equal or more to the
<code>mg_mgr_poll()</code> timeout.</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><code>mgr</code> - Pointer to <code>mg_mgr</code> event manager structure</li>
<li><code>ms</code> - An interval in milliseconds</li>
<li><code>flags</code> - Timer flags bitmask, <code>MG_TIMER_REPEAT</code> and <code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code> - Function to invoke</li>
<li><code>fn_data</code> - Function argument to be passed on call</li>
</ul>
<p>Return value: Pointer to created timer</p>
<p>Usage example:</p>
<pre><code class="language-c">void timer_fn(void *data) {
  // ...
}

mg_timer_add(mgr, 1000, MG_TIMER_REPEAT, timer_fn, NULL);
</code></pre>
<h3 id="struct-mg_timer">struct mg_timer</h3>
<pre><code class="language-c">struct mg_timer {
  uint64_t period_ms;       // Timer period in milliseconds
  uint64_t expire;          // Expiration timestamp in milliseconds
  unsigned flags;           // Possible flags values below
#define MG_TIMER_ONCE 0     // Call function once
#define MG_TIMER_REPEAT 1   // Call function periodically
#define MG_TIMER_RUN_NOW 2  // Call immediately when timer is set
  void (*fn)(void *);       // Function to call
  void *arg;                // Function argument
  struct mg_timer *next;    // Linkage
};
</code></pre>
<p>Timer structure. Describes a software timer. Timer granularity is the same
as the <code>mg_mgr_poll()</code> timeout argument in the main event loop.</p>
<h3 id="mg_timer_init">mg_timer_init()</h3>
<pre><code class="language-c">void mg_timer_init(struct mg_timer **head,
                   struct mg_timer *t, uint64_t period_ms, unsigned flags,
                   void (*fn)(void *), void *fn_data);
</code></pre>
<p>Setup a timer.</p>
<p>Parameters:</p>
<ul>
<li><code>head</code> - Pointer to <code>mg_timer</code> list head</li>
<li><code>t</code> - Pointer to <code>mg_timer</code> that should be initialized</li>
<li><code>ms</code> - An interval in milliseconds</li>
<li><code>flags</code> - Timer flags bitmask, <code>MG_TIMER_REPEAT</code> and <code>MG_TIMER_RUN_NOW</code></li>
<li><code>fn</code> - Function to invoke</li>
<li><code>fn_data</code> - Function argument to be passed on call</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">void timer_fn(void *data) {
  // ...
}

struct mg_timer timer, *head = NULL;
mg_timer_init(&amp;head, &amp;timer, 1000, MG_TIMER_REPEAT, timer_fn, NULL);
</code></pre>
<h3 id="mg_timer_free">mg_timer_free()</h3>
<pre><code class="language-c">void mg_timer_free(struct mg_timer **head, struct mg_timer *t);
</code></pre>
<p>Free timer, remove it from the internal timers list.</p>
<p>Parameters:</p>
<ul>
<li><code>head</code> - Pointer to <code>mg_timer</code> list head</li>
<li><code>t</code> - Timer to free</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_timer timer;
// ...
mg_timer_free(&amp;timer);
</code></pre>
<h3 id="mg_timer_poll">mg_timer_poll()</h3>
<pre><code class="language-c">void mg_timer_poll(struct mg_timer **head, uint64_t uptime_ms);
</code></pre>
<p>Traverse list of timers and call them if current timestamp <code>uptime_ms</code> is
past the timer&#39;s expiration time.</p>
<p>Note, that <code>mg_mgr_poll</code> function internally calls <code>mg_timer_poll</code>; therefore,
in most cases it is unnecessary to call it explicitly.</p>
<p>Parameters:</p>
<ul>
<li><code>head</code> - Pointer to <code>mg_timer</code> list head</li>
<li><code>uptime_ms</code> - current timestamp</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_timer_poll(mg_millis());
</code></pre>
<h2 id="time">Time</h2>
<h3 id="mg_millis">mg_millis()</h3>
<pre><code class="language-c">uint64_t mg_millis(void);
</code></pre>
<p>Return current uptime in milliseconds.</p>
<p>Parameters: None</p>
<p>Return value: Current uptime</p>
<p>Usage example:</p>
<pre><code class="language-c">uint64_t uptime = mg_millis();
</code></pre>
<h3 id="mg_now">mg_now()</h3>
<pre><code class="language-c">uint64_t mg_now(void);
</code></pre>
<p>Return current time in milliseconds, requires an SNTP server connection (<a href="#mg_sntp_connect">see mg_sntp_connect()</a>)</p>
<p>Parameters: None</p>
<p>Return value: If an SNTP server connection has been configured, returns current time. Otherwise, returns current uptime just like <code>mg_millis()</code></p>
<p>Usage example:</p>
<pre><code class="language-c">mg_sntp_connect(mgr&amp;, NULL /* connect to time.google.com */, NULL, NULL);
...
uint64_t curtime = mg_now();
</code></pre>
<h2 id="string">String</h2>
<h3 id="struct-mg_str">struct mg_str</h3>
<pre><code class="language-c">struct mg_str {
  const char *buf;  // Pointer to string data
  size_t len;       // String len
};
</code></pre>
<p>This structure represent an arbitrary chunk of memory, not necessarily
zero-terminated. This is a &quot;mongoose string&quot;, and it gets used extensively
in the codebase instead of C zero-terminated strings.</p>
<p>For example, when an HTTP request is received, Mongoose created a
<code>struct mg_http_message</code> which has a collection of <code>struct mg_str</code> pointing
to request method, URI, headers, and so on. This way, Mongoose avoids
any heap allocations and does not modify the received buffer - instead, it
uses <code>struct mg_str</code> to describe various parts of HTTP request.</p>
<p>Same goes with many other cases.</p>
<blockquote>
<p>NOTE: since <code>buf</code> is not necessarily zero-terminated, do not use libc string
functions against it - like <code>strlen()</code> or <code>sscanf()</code>.</p>
</blockquote>
<h3 id="mg_str">mg_str()</h3>
<pre><code class="language-c">struct mg_str mg_str(const char *s)
</code></pre>
<p>Create Mongoose string from NULL-terminated C-string. This function doesn&#39;t
duplicate provided string, and stores pointer within created <code>mg_str</code> structure.</p>
<p>Note, that is you have problems in C++ (constructor shadowing), there is <code>mg_str_s</code>
synonym for this function.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - Pointer to NULL-terminated string to store in created mg_str</li>
</ul>
<p>Return value: Created Mongoose string</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str str = mg_str(&quot;Hello, world!);
</code></pre>
<h3 id="mg_str_n">mg_str_n()</h3>
<pre><code class="language-c">struct mg_str mg_str_n(const char *s, size_t n);
</code></pre>
<p>Create Mongoose string from C-string <code>s</code> (can be non-NULL terminated, length is
specified in <code>n</code>). Note: This function doesn&#39;t duplicate provided string,
but stores pointer within created <code>mg_str</code> structure.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - Pointer to string to store in created <code>mg_str</code></li>
<li><code>n</code> - String length</li>
</ul>
<p>Return value: Created Mongoose string</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str str = mg_str_n(&quot;hi&quot;, 2);
</code></pre>
<h3 id="mg_casecmp">mg_casecmp()</h3>
<pre><code class="language-c">int mg_casecmp(const char *s1, const char *s2);
</code></pre>
<p>Case insensitive compare two NULL-terminated strings.</p>
<p>Parameters:</p>
<ul>
<li><code>s1</code>, <code>s2</code> - Pointers to strings to compare</li>
</ul>
<p>Return value: Zero if strings are equal, more than zero if first argument is greater then second, and less than zero otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">if (mg_casecmp(&quot;hello&quot;, &quot;HELLO&quot;) == 0) {
  // Strings are equal
}
</code></pre>
<h3 id="mg_strcmp">mg_strcmp()</h3>
<pre><code class="language-c">int mg_strcmp(const struct mg_str str1, const struct mg_str str2);
</code></pre>
<p>Compare two mongoose strings.</p>
<p>Parameters:</p>
<ul>
<li><code>str1</code>, <code>str2</code> - Pointers to Mongoose strings to compare</li>
</ul>
<p>Return value: Zero if strings are equal, more than zero if first argument is
greater than the second, and less than zero otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str str1 = mg_str(&quot;hello&quot;);
struct mg_str str2 = mg_str(&quot;hello&quot;);
if (mg_strcmp(str1, str2) == 0) {
  // Strings are equal
}
</code></pre>
<h3 id="mg_strcasecmp">mg_strcasecmp()</h3>
<pre><code class="language-c">int mg_strcasecmp(const struct mg_str str1, const struct mg_str str2);
</code></pre>
<p>Compare two mongoose strings, ignoring the case of the characters. </p>
<p>Parameters:</p>
<ul>
<li><code>str1</code>, <code>str2</code> - Pointers to Mongoose strings to compare</li>
</ul>
<p>Return value: Zero if strings are equal, more than zero if first argument is
greater than the second, and less than zero otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str str1 = mg_str(&quot;hello&quot;);
struct mg_str str2 = mg_str(&quot;HELLO&quot;);
if (mg_strcasecmp(str1, str2) == 0) {
  // Strings are equal
}
</code></pre>
<h3 id="mg_strdup">mg_strdup()</h3>
<pre><code class="language-c">struct mg_str mg_strdup(const struct mg_str s);
</code></pre>
<p>Duplicate provided string. Return new string or <code>MG_NULL_STR</code> on error.
Note: This function allocates memory for the returned string, you must free it using the <code>mg_free</code> function.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - Mongoose string to duplicate</li>
</ul>
<p>Return value: Duplicated string</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str str1 = mg_str(&quot;hello&quot;);
struct mg_str str2 = mg_strdup(str1);
//...
mg_free((void *)str2.buf);
</code></pre>
<h3 id="mg_match">mg_match()</h3>
<pre><code class="language-c">bool mg_match(struct mg_str str, struct mg_str pattern, struct mg_str *caps);
</code></pre>
<p>Check if string <code>str</code> matches glob pattern <code>pattern</code>, and optionally capture
wildcards into the provided array <code>caps</code>.</p>
<blockquote>
<p>NOTE: If <code>caps</code> is not NULL, then the <code>caps</code> array size must be at least the
number of wildcard symbols in <code>pattern</code> plus 1. The last cap will be
initialized to an empty string.</p>
</blockquote>
<p>The glob pattern matching rules are as follows:</p>
<ul>
<li><code>?</code> matches any single character</li>
<li><code>*</code> matches zero or more characters except <code>/</code></li>
<li><code>#</code> matches zero or more characters</li>
<li>any other character matches itself</li>
</ul>
<p>Parameters:</p>
<ul>
<li><code>str</code> - a string to match</li>
<li><code>pattern</code> - a pattern to match against</li>
<li><code>caps</code> - an optional array of captures for wildcard symbols <code>?</code>, <code>*</code>, &#39;#&#39;</li>
</ul>
<p>Return value: <code>true</code> if matches, <code>false</code> otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">// Assume that hm-&gt;uri holds /foo/bar. Then we can match the requested URI:
struct mg_str caps[3];  // Two wildcard symbols &#39;*&#39; plus 1
if (mg_match(hm-&gt;uri, mg_str(&quot;/*/*&quot;), caps)) {
  // caps[0] holds `foo`, caps[1] holds `bar`.
}
</code></pre>
<h3 id="mg_span">mg_span()</h3>
<pre><code class="language-c">bool mg_span(struct mg_str s, struct mg_str *a, struct mg_str *b, char delim);
</code></pre>
<p>Span string <code>s</code> at the first occurence of character <code>delim</code>. Sstore the
first part in <code>a</code>, and the rest of string in <code>b</code>. Both <code>a</code> and <code>b</code> can be NULL.
If <code>delim</code> is not present in <code>s</code>, then <code>a</code> spans to the end of <code>s</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - String being scanned</li>
<li><code>a</code> - Pointer to <code>mg_str</code> to store the prefix. Can be <code>NULL</code></li>
<li><code>b</code> - Pointer to <code>mg_str</code> to store the rest. Can be <code>NULL</code></li>
<li><code>delim</code> - A delimiter character</li>
</ul>
<p>Return value: <code>true</code> if <code>s</code> is non-empty, <code>false</code> if it is empty</p>
<p>Usage example - scan comma-separated key=value pairs:</p>
<pre><code class="language-c">struct mg_str entry, key, val;
struct mg_str s = mg_str(&quot;a=333,b=777,hello&quot;);

while (mg_span(&amp;s, &amp;entry, &amp;s, &#39;,&#39;)) {
  mg_span(entry, &amp;key, &amp;val, &#39;=&#39;);
  printf(&quot;key: %.*s, val: %.*s\n&quot;, (int) key.len, k.buf, (int) val.len, val.buf); 
}

// This loop outputs the following:
// key: a, val: 333
// key: b, val: 777
// key: hello, val:
</code></pre>
<img src="images/mg_commalist.svg" alt="Function mg_commalist()" />

<h3 id="mg_strtonum">mg_str\to\num()</h3>
<pre><code class="language-c">bool mg_str_to_num(struct mg_str s, int base, void *val, size_t val_len);
</code></pre>
<p>Parse the string <code>s</code> for unsigned numbers in base <code>base</code>. The result is stored at the address pointed to by <code>val</code>. No white space allowed.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - String to parse</li>
<li><code>base</code> - Number base: <code>2</code> for binary, <code>10</code> for decimal, <code>16</code> for hex; or <code>0</code> for auto, in which case binary numbers must start with <code>0b</code> and hexadecimal numbers with <code>0x</code>. When the base is specified, <em>do not</em> prepend these.</li>
<li><code>val</code> - Where to store the number</li>
<li><code>val_len</code> - destination size; e.g.: <code>sizeof(uint8_t)</code> to <code>sizeof(uint64_t)</code></li>
</ul>
<p>Return value: Returns <code>true</code> if a number has been parsed successfully</p>
<p>Usage example:</p>
<pre><code class="language-c">uint32_t val;
mg_str_to_num(mg_str_n(&quot;010203&quot;, 6), 16, &amp;val, sizeof(val)); // returns true and val is now 0x10203
</code></pre>
<h3 id="mg_path_is_sane">mg_path_is_sane()</h3>
<pre><code class="language-c">bool mg_path_is_sane(struct mg_str path);
</code></pre>
<p>Check <code>path</code> for starting with double dots in it.</p>
<p>Parameters:</p>
<ul>
<li><code>path</code> - Mongoose string to check</li>
</ul>
<p>Return value: true if OK, false otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">char data[] = &quot;../../a.txt&quot;;
bool res = mg_path_is_sane(mg_str(data));  // returns false
</code></pre>
<h3 id="mg_snprintf-mg_vsnprintf">mg_snprintf(), mg_vsnprintf()</h3>
<pre><code class="language-c">size_t mg_snprintf(char *buf, size_t len, const char *fmt, ...);
size_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list ap);
</code></pre>
<p>Print formatted string into a string buffer, just like <code>snprintf()</code>
standard function does, but in a predictable way that does not depend on
the C library or the build environment. The return value can be larger
than the buffer length <code>len</code>, in which case the overflow bytes are not printed.
Mongoose library supports two non-standard specifiers: <code>%M</code> and <code>%m</code>, for invoking custom print functions</p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - Pointer to pointer to output buffer</li>
<li><code>len</code> - Buffer size</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics.</li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Supported format specifiers:</p>
<ul>
<li><code>%c</code> - expect <code>char</code></li>
<li><code>%f</code>, <code>%g</code> - expect <code>double</code></li>
<li><code>%hhd</code>, <code>%hd</code>, <code>%d</code>, <code>%ld</code>, <code>%lld</code> - for <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>int64_t</code></li>
<li><code>%hhu</code>, <code>%hu</code>, <code>%u</code>, <code>%lu</code>, <code>%llu</code> - same but for unsigned variants</li>
<li><code>%hhx</code>, <code>%hx</code>, <code>%x</code>, <code>%lx</code>, <code>%llx</code> - same, unsigned and hex output</li>
<li><code>%p</code> - expects any pointer, prints <code>0x.....</code> hex value</li>
<li><code>%s</code> - expects <code>char *</code></li>
<li><code>%%</code> - prints the <code>%</code> character itself</li>
<li><code>%X.Y</code> - optional width and precision modifiers (e.g.: <code>%1.2d</code>)</li>
<li><code>%.*</code> - optional precision modifier, expected as <code>int</code> argument (e.g.: <code>%.*d</code>)</li>
<li><code>%M</code> - (EXTENSION) expects a pointer to a custom print function and its arguments</li>
<li><code>%m</code> - (EXTENSION) exactly like <code>%M</code> but double-quotes the output</li>
</ul>
<p>List of built-in print functions for <code>%m</code> or <code>%M</code>:</p>
<ul>
<li><a href="#mg_print_base64">mg_print_base64</a> - prints a buffer as a base64-encoded string</li>
<li><a href="#mg_print_esc">mg_print_esc</a> - prints a JSON-escaped string</li>
<li><a href="#mg_print_hex">mg_print_hex</a> - prints a buffer as a hex string</li>
<li><a href="#mg_print_ip">mg_print_ip</a>   - prints an IP address in a <code>struct mg_str</code></li>
<li><a href="#mg_print_ip_port">mg_print_ip_port</a> - prints IP address and port in a <code>struct mg_str</code></li>
<li><a href="#mg_print_ip4">mg_print_ip4</a> - prints an IPv4 address</li>
<li><a href="#mg_print_ip6">mg_print_ip6</a> - prints an IPv6 address</li>
<li><a href="#mg_print_mac">mg_print_mac</a> - prints a MAC address</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;%lld&quot;, (int64_t) 123);                  // 123                  (64-bit integer)
mg_snprintf(buf, sizeof(buf), &quot;%.2s&quot;, &quot;abcdef&quot;);                       // ab                   (part of a string)   
mg_snprintf(buf, sizeof(buf), &quot;%.*s&quot;, 2, &quot;abcdef&quot;);                    // ab                   (part of a string) 
mg_snprintf(buf, sizeof(buf), &quot;%05x&quot;, 123);                            // 00123                (padded integer)
mg_snprintf(buf, sizeof(buf), &quot;%%-%3s&quot;, &quot;a&quot;);                          // %-  a                (padded string)
mg_snprintf(buf, sizeof(buf), &quot;hi, %m&quot;, mg_print_base64, 1, &quot;a&quot;);      // hi, &quot;YWJj&quot;           (base64-encode)
mg_snprintf(buf, sizeof(buf), &quot;[%m]&quot;, mg_print_esc, 0, &quot;two\nlines&quot;);  // [&quot;two\nlines&quot;]       (JSON-escaped string)
mg_snprintf(buf, sizeof(buf), &quot;{%m:%g}&quot;, mg_print_esc, 0, &quot;val&quot;, 1.2); // {&quot;val&quot;: 1.2}         (JSON object)
mg_snprintf(buf, sizeof(buf), &quot;hi, %M&quot;, mg_print_hex, 3, &quot;abc&quot;);       // hi, 616263           (hex-encode)
mg_snprintf(buf, sizeof(buf), &quot;IP: %M&quot;, mg_print_ip, &amp;c-&gt;rem);         // IP: 1.2.3.4          (struct mg_addr)
mg_snprintf(buf, sizeof(buf), &quot;Peer: %M&quot;, mg_print_ip_port, &amp;c-&gt;rem);  // Peer: 1.2.3.4:21345  (struct mg_addr with port)
mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_ip4, &quot;abcd&quot;);             // 97.98.99.100         (IPv4 address)
mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_ip6, &quot;abcdefghijklmnop&quot;); // [4142:4344:4546:4748:494a:4b4c:4d4e:4f50]
mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_mac, &quot;abcdef&quot;);           // 61:62:63:64:65:66    (MAC address)
</code></pre>
<p>It is easy to implement a custom print function. For example, to format
a structure as JSON string:</p>
<pre><code class="language-c">struct a { int a, b; };

size_t print_a(void (*out)(char, void *), void *ptr, va_list *ap) {
  struct a *ptr = va_arg(*ap, struct a *);
  return mg_xprintf(out, ptr, &quot;{%m:%d}&quot;, MG_ESC(&quot;a&quot;), ptr-&gt;a); // MG_ESC invokes mg_print_esc
}

struct a temp = { 42, 43 };
mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, print_a, &amp;temp);    // {&quot;a&quot;:42}
</code></pre>
<h3 id="mg_mprintf-mg_vmprintf">mg_mprintf(), mg_vmprintf()</h3>
<pre><code class="language-c">char *mg_mprintf(const char *fmt, ...);
char *mg_vmprintf(const char *fmt, va_list *ap);
</code></pre>
<p>Print message into an allocated memory buffer. Caller must <code>mg_free()</code> the result.</p>
<p>Parameters:</p>
<ul>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: allocated memory buffer</p>
<p>Usage example:</p>
<pre><code class="language-c">char *msg = mg_mprintf(&quot;Build the message: %s&quot;, &quot;hi!&quot;);
mg_free(msg);
</code></pre>
<h3 id="mg_xprintf-mg_vxprintf">mg_xprintf(), mg_vxprintf()</h3>
<pre><code class="language-c">size_t mg_xprintf(void (*out)(char, void *), void *param, const char *fmt, ...);
size_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,
                   va_list *ap);
</code></pre>
<p>Print message using a specified character output function</p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">void myfn(char c, void *p);

size_t len = mg_xprintf(myfn, myfn_p, &quot;Print the string: %s!&quot;, &quot;hi&quot;);
</code></pre>
<h3 id="mg_pfn_iobuf">mg_pfn_iobuf()</h3>
<pre><code class="language-c">void mg_pfn_iobuf(char ch, void *param); 
</code></pre>
<p>Print a character to a <a href="#struct-mg_iobuf">Generic IO buffer</a> </p>
<p>Parameters:</p>
<ul>
<li><code>ch</code> - char to be printed</li>
<li><code>param</code> - must be <code>struct mg_iobuf *</code></li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">mg_xprintf(mg_pfn_iobuf, &amp;c-&gt;send, &quot;hi!&quot;);  // Append to the output buffer
</code></pre>
<h3 id="mg_aton">mg_aton()</h3>
<pre><code class="language-c">bool mg_aton(struct mg_str str, struct mg_addr *addr);
</code></pre>
<p>Parse IP address held by <code>str</code> and store it in <code>addr</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>str</code> - String to parse, for example <code>1.2.3.4</code>, <code>[::1]</code>, <code>01:02::03</code></li>
<li><code>addr</code> - Pointer to <code>mg_addr</code> string to receive parsed value</li>
</ul>
<p>Return value: <code>true</code> on success, <code>false</code> otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_addr addr;
if (mg_aton(mg_str(&quot;127.0.0.1&quot;), &amp;addr)) {
  // addr is now binary representation of 127.0.0.1 IP address
}
</code></pre>
<h2 id="json">JSON</h2>
<p>Mongoose library is often used to exchange data in JSON format, therefore we have provided utility functions to format JSON strings easily:</p>
<pre><code class="language-c">mg_http_reply(c, 200, &quot;Content-Type: application/json\r\n&quot;,
              &quot;{%m: %u}&quot;, MG_ESC(&quot;value&quot;), 123);  // {&quot;value&quot;: 123}
</code></pre>
<p>Therefore, for full JSON support, a set of parsing functions is required -
which is described below.</p>
<h3 id="mg_json_get">mg_json_get()</h3>
<pre><code class="language-c">enum { MG_JSON_TOO_DEEP = -1, MG_JSON_INVALID = -2, MG_JSON_NOT_FOUND = -3 };
int mg_json_get(struct mg_str json, const char *path, int *toklen);
</code></pre>
<p>Parse JSON string <code>json</code> and return the offset of the element
specified by the JSON <code>path</code>. The length of the element is stored
in the <code>toklen</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code>, e.g. <code>$.user</code></li>
<li><code>toklen</code> - a pointer that receives element&#39;s length, can be NULL</li>
</ul>
<p>Return value: offset of the element, or negative <code>MG_JSON_*</code> on error.</p>
<p>Usage example:</p>
<pre><code class="language-c">// Create a json string: { &quot;a&quot;: 1, &quot;b&quot;: [2, 3] }
char *buf = mg_mprintf(&quot;{ %m: %d, %m: [%d, %d] }&quot;,
                       MG_ESC(&quot;a&quot;), 1,
                       MG_ESC(&quot;b&quot;), 2, 3);
struct mg_str json = mg_str(buf);
int offset, length;

// Lookup &quot;$&quot;, which is the whole JSON. Can be used for validation
offset = mg_json_get(json, &quot;$&quot;, &amp;length);    // offset = 0, length = 23

// Lookup attribute &quot;a&quot;. Point to value &quot;1&quot;
offset = mg_json_get(json, &quot;$.a&quot;, &amp;length);  // offset = 7, length = 1

// Lookup attribute &quot;b&quot;. Point to array [2, 3]
offset = mg_json_get(json, &quot;$.b&quot;, &amp;length);  // offset = 15, length = 6

// Lookup attribute &quot;b[1]&quot;. Point to value &quot;3&quot;
offset = mg_json_get(json, &quot;$.b[1]&quot;, &amp;length); // offset = 19, length = 1

mg_free(buf);
</code></pre>
<h3 id="mg_json_get_tok">mg_json_get_tok()</h3>
<pre><code class="language-c">struct mg_str mg_json_get_tok(struct mg_str json, const char *path);
</code></pre>
<p>Parse JSON string <code>json</code> and return a <code>struct mg_str</code> pointing to the value of the element
specified by the JSON <code>path</code>. Useful to check if a token is present, or inspect when it can have different types.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code>, e.g. <code>$.user</code></li>
</ul>
<p>Return value: a <code>struct mg_str</code> pointing to the value of the element, or with a NULL pointer on error.</p>
<p>Usage example:</p>
<pre><code class="language-c">  json = mg_str(&quot;{\&quot;a\&quot;:\&quot;b:c\&quot;}&quot;);
  val = mg_json_get_tok(json, &quot;$.a&quot;); // &quot;b:c&quot;
</code></pre>
<h3 id="mg_json_get_num">mg_json_get_num()</h3>
<pre><code class="language-c">bool mg_json_get_num(struct mg_str json, const char *path, double *v);
</code></pre>
<p>Fetch numeric (double) value from the json string <code>json</code> at JSON path
<code>path</code> into a placeholder <code>v</code>. Return true if successful.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code></li>
<li><code>v</code> - a placeholder for value</li>
</ul>
<p>Return value: true on success, false on error</p>
<p>Usage example:</p>
<pre><code class="language-c">double d = 0.0;
mg_json_get_num(mg_str(&quot;[1,2,3]&quot;, &quot;$[1]&quot;, &amp;d));     // d == 2
mg_json_get_num(mg_str(&quot;{\&quot;a\&quot;:1.23}&quot;, &quot;$.a&quot;, &amp;d)); // d == 1.23
</code></pre>
<h3 id="mg_json_get_bool">mg_json_get_bool()</h3>
<pre><code class="language-c">bool mg_json_get_bool(struct mg_str json, const char *path, bool *v);
</code></pre>
<p>Fetch boolean (bool) value from the json string <code>json</code> at JSON path
<code>path</code> into a placeholder <code>v</code>. Return true if successful.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code></li>
<li><code>v</code> - a placeholder for value</li>
</ul>
<p>Return value: true on success, false on error</p>
<p>Usage example:</p>
<pre><code class="language-c">bool b = false;
mg_json_get_bool(mg_str(&quot;[123]&quot;, &quot;$[0]&quot;, &amp;b));   // Error. b remains to be false
mg_json_get_bool(mg_str(&quot;[true]&quot;, &quot;$[0]&quot;, &amp;b));  // b is true
</code></pre>
<h3 id="mg_json_get_long">mg_json_get_long()</h3>
<pre><code class="language-c">long mg_json_get_long(struct mg_str json, const char *path, long default_val);
</code></pre>
<p>Fetch integer numeric (long) value from the json string <code>json</code> at JSON path
<code>path</code>. Return it if found, or <code>default_val</code> if not found.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code></li>
<li><code>default_val</code> - a default value for the failure case</li>
</ul>
<p>Return value: found value, or <code>default_val</code> value</p>
<p>Usage example:</p>
<pre><code class="language-c">long a = mg_json_get_long(mg_str(&quot;[123]&quot;, &quot;$a&quot;, -1));   // a = -1
long b = mg_json_get_long(mg_str(&quot;[123]&quot;, &quot;$[0]&quot;, -1)); // b = 123
</code></pre>
<h3 id="mg_json_get_str">mg_json_get_str()</h3>
<pre><code class="language-c">char *mg_json_get_str(struct mg_str json, const char *path);
</code></pre>
<p>Fetch string value from the json string <code>json</code> at JSON path
<code>path</code>. If found, a string is allocated using <code>mg_calloc()</code>,
un-escaped, and returned to the caller. It is the caller&#39;s responsibility to
<code>mg_free()</code> the returned string.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code></li>
</ul>
<p>Return value: non-NULL on success, NULL on error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str json = mg_str(&quot;{\&quot;a\&quot;: \&quot;hi\&quot;}&quot;);  // json = {&quot;a&quot;: &quot;hi&quot;}
char *str = mg_json_get_str(json, &quot;$.a&quot;);        // str = &quot;hi&quot;
mg_free(str);
</code></pre>
<h3 id="mg_json_get_hex">mg_json_get_hex()</h3>
<pre><code class="language-c">char *mg_json_get_hex(struct mg_str json, const char *path, int *len);
</code></pre>
<p>Fetch hex-encoded buffer from the json string <code>json</code> at JSON path
<code>path</code>. If found, a buffer is allocated using <code>mg_calloc()</code>, decoded,
and returned to the caller. It is the caller&#39;s responsibility to
<code>mg_free()</code> the returned string. Returned buffer is nul-terminated.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code></li>
<li><code>len</code> - a pointer that receives decoded length. Can be NULL</li>
</ul>
<p>Return value: non-NULL on success, NULL on error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str json = mg_str(&quot;{\&quot;a\&quot;: \&quot;6869\&quot;}&quot;); // json = {&quot;a&quot;: &quot;6869&quot;}
char *str = mg_json_get_hex(json, &quot;$.a&quot;, NULL);   // str = &quot;hi&quot;
mg_free(str);
</code></pre>
<h3 id="mg_json_get_b64">mg_json_get_b64()</h3>
<pre><code class="language-c">char *mg_json_get_b4(struct mg_str json, const char *path, int *len);
</code></pre>
<p>Fetch base64-encoded buffer from the json string <code>json</code> at JSON path
<code>path</code>. If found, a buffer is allocated using <code>mg_calloc()</code>, decoded,
and returned to the caller. It is the caller&#39;s responsibility to
<code>mg_free()</code> the returned string. Returned buffer is nul-terminated.</p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>path</code> - a JSON path. Must start with <code>$</code></li>
<li><code>len</code> - a pointer that receives decoded length. Can be NULL</li>
</ul>
<p>Return value: non-NULL on success, NULL on error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str json = mg_str(&quot;{\&quot;a\&quot;: \&quot;YWJj\&quot;}&quot;); // json = {&quot;a&quot;: &quot;YWJj&quot;}
char *str = mg_json_get_b64(json, &quot;$.a&quot;, NULL);   // str = &quot;abc&quot;
mg_free(str);
</code></pre>
<h3 id="mg_json_unescape">mg_json_unescape()</h3>
<pre><code class="language-c">bool mg_json_unescape(struct mg_str str, char *buf, size_t len);
</code></pre>
<p>Unescape a JSON string</p>
<p>Parameters:</p>
<ul>
<li><code>str</code> - a string containing valid JSON to be unescaped</li>
<li><code>buf</code> - buffer where to place the result</li>
<li><code>len</code> - buffer length</li>
</ul>
<p>Return value: true on success, false on error</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str str = mg_str(&quot;{\&quot;a\&quot;: \&quot;b\\u0063d\&quot;}&quot;); // escaped json = {&quot;a&quot;: &quot;b\u0063d&quot;}
char json[20];
bool result = mg_json_unescape(str, result, 20);    // json = {&quot;a&quot;: &quot;bcd&quot;}
</code></pre>
<h3 id="mg_json_next">mg_json_next()</h3>
<pre><code class="language-c">size_t mg_json_next(struct mg_str obj, size_t ofs, struct mg_str *key, struct mg_str *val);
</code></pre>
<p>Iterate over elements of an object or array. An initial value for <code>ofs</code> must be
0, then on each iteration a previously returned value should be passed. </p>
<p>Parameters:</p>
<ul>
<li><code>json</code> - a string containing valid JSON</li>
<li><code>ofs</code> - an offset of the element</li>
<li><code>key</code> - a pointer that receives key. For arrays, set to empty. Can be NULL</li>
<li><code>val</code> - a pointer that receives value. Can be NULL</li>
</ul>
<p>Return value: non-0 on success, 0 when there are no more elements</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str key, val, obj = mg_str(&quot;{\&quot;a\&quot;: [true], \&quot;b\&quot;: 12345}&quot;);
size_t ofs = 0;
while ((ofs = mg_json_next(obj, ofs, &amp;key, &amp;val)) &gt; 0) {
  printf(&quot;%.*s -&gt; %.*s\n&quot;, (int) key.len, key.buf, (int) val.len, val.buf);
}
</code></pre>
<p>For an example on how to iterate over an arbitrary JSON string, see
<a href="https://github.com/cesanta/mongoose/blob/d18b2b390a7b6801349f1f62aa6d24ab67514fa6/test/unit_test.c#L2790-L2804">json_scan()</a>
function in the unit test.</p>
<h2 id="rpc">RPC</h2>
<p>Mongoose includes a set of functions to ease server-side processing by means of RPC methods.</p>
<h3 id="struct-mg_rpc">struct mg_rpc</h3>
<p>The RPC method handler structure. Each method has an entry in a linked list, each entry points to a string describing the pattern that will invoke it and the function that will be called to satisfy the method invocation, with a proper function argument.</p>
<pre><code class="language-c">struct mg_rpc {
  struct mg_rpc *next;              // Next in list
  struct mg_str method;             // Method pattern
  void (*fn)(struct mg_rpc_req *);  // Handler function
  void *fn_data;                    // Handler function argument
};
</code></pre>
<h3 id="struct-mg_rpc_req">struct mg_rpc_req</h3>
<p>The RPC request descriptor. An invoked method receives a descriptor containing the request, and a pointer to a function to be called to print the output response, with a proper function argument; e.g.: <a href="#mg_pfn_realloc">mg_pfn_realloc()</a> or <a href="#mg_pfn_iobuf">mg_pfn_iobuf()</a></p>
<pre><code class="language-c">struct mg_rpc_req {
  struct mg_rpc **head;  // RPC handlers list head
  struct mg_rpc *rpc;    // RPC handler being called
  mg_pfn_t pfn;          // Response printing function
  void *pfn_data;        // Response printing function data
  void *req_data;        // Arbitrary request data
  struct mg_str frame;   // Request, e.g. {&quot;id&quot;:1,&quot;method&quot;:&quot;add&quot;,&quot;params&quot;:[1,2]}
};
</code></pre>
<h3 id="mg_rpc_add">mg_rpc_add()</h3>
<pre><code class="language-c">void mg_rpc_add(struct mg_rpc **head, struct mg_str method_pattern,
                void (*handler)(struct mg_rpc_req *), void *handler_data);
</code></pre>
<p>Add the method <code>method_pattern</code> to the list <code>head</code> of RPC methods. Invoking this method will call <code>handler</code> and pass <code>handler_data</code> to it with the request (as <code>r-&gt;fn_data</code> in the usage example below).</p>
<p>Parameters:</p>
<ul>
<li><code>head</code> - the linked list pointer</li>
<li><code>method_pattern</code> - the name of the method</li>
<li><code>handler</code> - the RPC function performing the action for this method</li>
<li><code>handler_data</code> - Arbitrary function data</li>
</ul>
<blockquote>
<p>NOTE: if <code>method_pattern</code> is an empty string, this handler will be called to
process JSON-RPC responses. Handling responses might be necessary if the JSON
requests are initiated by both sides.</p>
</blockquote>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_rpc *s_rpc_head = NULL;

static void rpc_sum(struct mg_rpc_req *r) {
  double a = 0.0, b = 0.0;
  mg_json_get_num(r-&gt;frame, &quot;$.params[0]&quot;, &amp;a);
  mg_json_get_num(r-&gt;frame, &quot;$.params[1]&quot;, &amp;b);
  mg_rpc_ok(r, &quot;%g&quot;, a + b);
}

static void rpc_mul(struct mg_rpc_req *r) {//...}


  mg_rpc_add(&amp;s_rpc_head, mg_str(&quot;sum&quot;), rpc_sum, NULL);
  mg_rpc_add(&amp;s_rpc_head, mg_str(&quot;mul&quot;), rpc_mul, NULL);
</code></pre>
<h3 id="mg_rpc_del">mg_rpc_del()</h3>
<pre><code class="language-c">void mg_rpc_del(struct mg_rpc **head, void (*handler)(struct mg_rpc_req *));
</code></pre>
<p>Remove the method with RPC function handler <code>handler</code> from the list <code>head</code> of RPC methods.</p>
<p>Parameters:</p>
<ul>
<li><code>head</code> - the linked list pointer</li>
<li><code>handler</code> - the RPC function performing the action for this method, use NULL to deallocate all</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_rpc *s_rpc_head = NULL;
// add methods
// ...

// Time to cleanup
mg_rpc_del(&amp;s_rpc_head, rpc_mul);    // Deallocate specific handler
mg_rpc_del(&amp;s_rpc_head, NULL);       // Deallocate all RPC handlers
</code></pre>
<h3 id="mg_rpc_process">mg_rpc_process()</h3>
<pre><code class="language-c">void mg_rpc_process(struct mg_rpc_req *req);
</code></pre>
<p>Invoke the proper method for this request. If the requested method does not exist, <code>mg_rpc_err()</code> will be invoked and an error indication will be printed</p>
<p>Parameters:</p>
<ul>
<li><code>req</code> - a request</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_rpc *s_rpcs = NULL;                               // Empty RPC list head
mg_rpc_add(&amp;s_rpcs, mg_str(&quot;rpc.list&quot;), mg_rpc_list, NULL); // Add rpc.list
// ... add more RPC methods

// On request, process the incoming frame
struct mg_str req = mg_str(&quot;{\&quot;id\&quot;:1,\&quot;method\&quot;:\&quot;sum\&quot;,\&quot;params\&quot;:[1,2]}&quot;);
struct mg_iobuf io = {0, 0, 0, 512};  // Empty IO buf, with 512 realloc granularity
struct mg_rpc_req r = {
  .head = &amp;s_rpcs,        // RPC list head
  .rpc = NULL,            // This will be set by mg_rpc_process()
  .pfn = mg_pfn_iobuf,    // Printing function: print into the io buffer
  .pfn_data = &amp;io,        // Pass our io buffer as a parameter
  .req_data = NULL,       // No specific request data
  .frame = req,           // Specify incoming frame
};

mg_rpc_process(&amp;r);
if (io.buf != NULL) printf(&quot;Response: %s\n&quot;, (char *) io.buf);
mg_iobuf_free(&amp;io);
</code></pre>
<h3 id="mg_rpc_ok-mg_rpc_vok">mg_rpc_ok(), mg_rpc_vok()</h3>
<pre><code class="language-c">void mg_rpc_ok(struct mg_rpc_req *, const char *fmt, ...);
void mg_rpc_vok(struct mg_rpc_req *, const char *fmt, va_list *ap);
</code></pre>
<p>Helper functions to print result frames</p>
<p>Parameters:</p>
<ul>
<li><code>req</code> - a request</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">static void rpc_sum(struct mg_rpc_req *r) {
  double a = 0.0, b = 0.0;
  mg_json_get_num(r-&gt;frame, &quot;$.params[0]&quot;, &amp;a);
  mg_json_get_num(r-&gt;frame, &quot;$.params[1]&quot;, &amp;b);
  mg_rpc_ok(r, &quot;%g&quot;, a + b);
}
</code></pre>
<h3 id="mg_rpc_err-mg_rpc_verr">mg_rpc_err(), mg_rpc_verr()</h3>
<pre><code class="language-c">void mg_rpc_err(struct mg_rpc_req *, int code, const char *fmt, ...);
void mg_rpc_verr(struct mg_rpc_req *, int code, const char *fmt, va_list *);
</code></pre>
<p>Helper functions to print error frames</p>
<p>Parameters:</p>
<ul>
<li><code>req</code> - a request</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">static void rpc_dosome(struct mg_rpc_req *r) {
  ...
  mg_rpc_err(r, -32109, &quot;\&quot;%.*s not found\&quot;&quot;, len, &amp;r-&gt;frame.buf[offset]);
}
</code></pre>
<h3 id="mg_rpc_list">mg_rpc_list()</h3>
<pre><code class="language-c">void mg_rpc_list(struct mg_rpc_req *r);
</code></pre>
<p>Built-in RPC method to list all registered RPC methods. This function is not usually called directly, but registered as a method.</p>
<p>Parameters:</p>
<ul>
<li><code>req</code> - a request</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">mg_rpc_add(&amp;s_rpc_head, mg_str(&quot;rpc.list&quot;), mg_rpc_list, &amp;s_rpc_head);
</code></pre>
<p>(see also <a href="#mg_rpc_add">mg_rpc_add()</a>)</p>
<h2 id="utility">Utility</h2>
<h3 id="mg_call">mg_call()</h3>
<pre><code class="language-c">void mg_call(struct mg_connection *c, int ev, void *ev_data);
</code></pre>
<p>Send <code>ev</code> event to <code>c</code> event handler. This function is useful then implementing
your own protocol.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to send event</li>
<li><code>ev</code> - Event to send</li>
<li><code>ev_data</code> - Additional event parameter</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">// In a timer callback, send MG_EV_USER event to all connections
static void timer_fn(void *arg) {
  struct mg_mgr *mgr = (struct mg_mgr *) arg;
  for (struct mg_connection *c = mgr-&gt;conns; c != NULL; c = c-&gt;next) {
    mg_call(c, MG_EV_USER, &quot;hi!&quot;);
  }
}
</code></pre>
<h3 id="mg_error">mg_error()</h3>
<pre><code class="language-c">void mg_error(struct mg_connection *c, const char *fmt, ...);
</code></pre>
<p>Send <code>MG_EV_ERROR</code> to connection event handler with error message formatted using printf semantics.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Connection to send event</li>
<li><code>fmt</code> - Format string in <code>printf</code> semantics</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_error(c, &quot;Operation failed, error code: %d&quot;, errno);
</code></pre>
<h3 id="mg_md5_init">mg_md5_init()</h3>
<pre><code class="language-c">void mg_md5_init(mg_md5_ctx *c);
</code></pre>
<p>Initialize context for MD5 hashing.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - Pointer to <code>mg_md5_ctx</code> structure to initialize</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_md5_ctx ctx;
mg_md5_init(&amp;ctx);
</code></pre>
<h3 id="mg_md5_update">mg_md5_update()</h3>
<pre><code class="language-c">void mg_md5_update(mg_md5_ctx *c, const unsigned char *data, size_t len);
</code></pre>
<p>Hash <code>len</code> bytes of data pointed by <code>data</code> using MD5 algorithm.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - MD5 context</li>
<li><code>data</code> - Data to hash</li>
<li><code>len</code> - Data length</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_md5_ctx ctx;
// Context initialization
// ...

mg_md5_update(&amp;ctx, &quot;data&quot;, 4);       // hash &quot;data&quot; string
mg_md5_update(&amp;ctx, &quot;more data&quot;, 9);  // hash &quot;more data&quot; string
</code></pre>
<h3 id="mg_md5_final">mg_md5_final()</h3>
<pre><code class="language-c">void mg_md5_final(mg_md5_ctx *c, unsigned char buf[16]);
</code></pre>
<p>Get current MD5 hash for context.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - MD5 context</li>
<li><code>buf</code> - Pointer to buffer to write MD5 hash value</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_md5_ctx ctx;
// Context initialization
// ...

unsigned char buf[16];
mg_md5_final(&amp;ctx, buf);  // `buf` is now MD5 hash
</code></pre>
<h3 id="mg_sha1_init">mg_sha1_init()</h3>
<pre><code class="language-c">void mg_sha1_init(mg_sha1_ctx *c);
</code></pre>
<p>Initialize context for calculating SHA1 hash</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - pointer to <code>mg_sha1_ctx</code> structure to initialize</li>
</ul>
<p>Return value: none</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_sha1_ctx ctx;
mg_sha1_init(&amp;ctx);
</code></pre>
<h3 id="mg_sha1_update">mg_sha1_update()</h3>
<pre><code class="language-c">void mg_sha1_update(mg_sha1_ctx *c, const unsigned char *data, size_t len);
</code></pre>
<p>Hash <code>len</code> bytes of <code>data</code> using SHA1 algorithm.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - SHA1 context</li>
<li><code>data</code> - Data to hash</li>
<li><code>len</code> - Data length</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_sha1_ctx ctx;
// Context initialization
// ...

mg_sha1_update(&amp;ctx, &quot;data&quot;, 4);      // hash &quot;data&quot; string
mg_sha1_update(&amp;ctx, &quot;more data&quot;, 9); // hash &quot;more data&quot; string
</code></pre>
<h3 id="mg_sha1_final">mg_sha1_final()</h3>
<pre><code class="language-c">void mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *c);
</code></pre>
<p>Get current SHA1 hash for context.</p>
<p>Parameters:</p>
<ul>
<li><code>c</code> - SHA1 context</li>
<li><code>digest</code> - Pointer to buffer to receive hash value</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_sha1_ctx ctx;
// Context initialization
// ...

unsigned char buf[20];
mg_sha1_final(buf, &amp;ctx); // `buf` is now SHA1 hash
</code></pre>
<h3 id="mg_base64_update">mg_base64_update()</h3>
<pre><code class="language-c">size_t mg_base64_update(unsigned char p, char *buf, size_t len);
</code></pre>
<p>Encode <code>p</code> byte to base64 and write result into <code>buf</code> buffer</p>
<p>Parameters:</p>
<ul>
<li><code>p</code> - Byte to encode</li>
<li><code>buf</code> - Pointer to buffer to write result</li>
<li><code>len</code> - Buffer length</li>
</ul>
<p>Return value: Number of chars written into buffer</p>
<p>Usage example:</p>
<pre><code class="language-c">char buf[10];
mg_base64_update((unsigned char)&quot;a&quot;, buf, 10); // Encode &quot;a&quot; into base64 and write it to buf
</code></pre>
<h3 id="mg_base64_final">mg_base64_final()</h3>
<pre><code class="language-c">size_t mg_base64_final(char *buf, size_t len);
</code></pre>
<p>Add base64 finish mark and <code>\0</code> symbol to <code>buf</code></p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - Pointer to buffer to write finish mark</li>
<li><code>len</code> - Buffer length</li>
</ul>
<p>Return value: Number of chars written into buffer</p>
<pre><code class="language-c">char buf[10];
// ...

mg_base64_final(buf, 10);
</code></pre>
<h3 id="mg_base64_encode">mg_base64_encode()</h3>
<pre><code class="language-c">size_t mg_base64_encode(const unsigned char *p, size_t n, char *buf, size_t len);
</code></pre>
<p>Encode <code>n</code> bytes data pointed to by <code>p</code> using base64 and write result into <code>buf</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>p</code> - Pointer to data to encode</li>
<li><code>n</code> - Data length</li>
<li><code>buf</code> - Pointer to buffer to write result</li>
<li><code>len</code> - Buffer length</li>
</ul>
<p>Return value: Number of chars written into buffer</p>
<p>Usage example:</p>
<pre><code class="language-c">char buf[128];
mg_base64_encode((uint8_t *) &quot;abcde&quot;, 5, buf, 128); // buf is now YWJjZGU=
</code></pre>
<h3 id="mg_base64_decode">mg_base64_decode()</h3>
<pre><code class="language-c">size_t mg_base64_decode(const char *src, size_t n, char *dst, size_t len);
</code></pre>
<p>Decode <code>n</code> bytes of base64-ed <code>src</code> and write it to <code>dst</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>src</code> - Data to decode</li>
<li><code>n</code> - Data length</li>
<li><code>dst</code> - Pointer to output buffer</li>
<li><code>len</code> - Buffer length</li>
</ul>
<p>Return value: Number of chars written into buffer</p>
<p>Usage example:</p>
<pre><code class="language-c">char buf[128];
mg_base64_decode(&quot;Q2VzYW50YQ==&quot;, 12, buf, 128); // buf is now &quot;Cesanta&quot;
</code></pre>
<h3 id="mg_random">mg_random()</h3>
<pre><code class="language-c">bool mg_random(void *buf, size_t len);
</code></pre>
<p>Fill in buffer <code>buf</code>, <code>len</code> with random data. Note: Mongoose uses this
function for TLS and some other routines that require RNG (random number
generator). It is possible to override a built-in <code>mg_random()</code> by specifying
a <code>MG_ENABLE_CUSTOM_RANDOM=1</code> build preprocessor constant.</p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - Pointer to buffer to receive random data</li>
<li><code>len</code> - Buffer size</li>
</ul>
<p>Return value: This function returns <code>false</code> when the system <code>rand()</code> has to be used, because a stronger PRNG for the configured MG_ARCH could not be found.</p>
<p>Usage example:</p>
<pre><code class="language-c">char buf[10];
mg_random(buf, sizeof(buf)); // `buf` is now random bytes
</code></pre>
<h3 id="mg_random_str">mg_random_str()</h3>
<pre><code class="language-c">char *mg_random_str(char *buf, size_t len);
</code></pre>
<p>Fill in buffer <code>buf</code>, <code>len</code> with random alphanumeric characters: <code>a-zA-Z0-9</code>.
A buffer is zero-terminated.</p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - a pointer to a buffer</li>
<li><code>len</code> - a buffer size</li>
</ul>
<p>Return value: <code>buf</code> value.</p>
<p>Usage example:</p>
<pre><code class="language-c">char buf[10];
printf(&quot;Random: %s\n&quot;, mg_random_str(buf, sizeof(buf)));
</code></pre>
<h3 id="mg_ntohs">mg_ntohs()</h3>
<pre><code class="language-c">uint16_t mg_ntohs(uint16_t net);
</code></pre>
<p>Convert <code>uint16_t</code> value to host order.</p>
<p>Parameters:</p>
<ul>
<li><code>net</code> - 16-bit value in network order</li>
</ul>
<p>Return value: 16-bit value in host order</p>
<p>Usage example:</p>
<pre><code class="language-c">uint16_t val = mg_ntohs(0x1234);
</code></pre>
<h3 id="mg_ntohl">mg_ntohl()</h3>
<pre><code class="language-c">uint32_t mg_ntohl(uint32_t net);
</code></pre>
<p>Convert <code>uint32_t</code> value to host order.</p>
<p>Parameters:</p>
<ul>
<li><code>net</code> - 32-bit value in network order</li>
</ul>
<p>Return value: 32-bit value in host order</p>
<p>Usage example:</p>
<pre><code class="language-c">uint32_t val = mg_ntohl(0x12345678);
</code></pre>
<h3 id="mg_htons">mg_htons()</h3>
<pre><code class="language-c">uint16_t mg_htons(uint16_t h);
</code></pre>
<p>Convert <code>uint16_t</code> value to network order.</p>
<p>Parameters:</p>
<ul>
<li><code>h</code> - 16-bit value in host order</li>
</ul>
<p>Return value: 16-bit value in network order</p>
<p>Usage example:</p>
<pre><code class="language-c">uint16_t val = mg_htons(0x1234);
</code></pre>
<h3 id="mg_htonl">mg_htonl()</h3>
<pre><code class="language-c">uint32_t mg_ntohl(uint32_t h);
</code></pre>
<p>Convert <code>uint32_t</code> value to network order.</p>
<p>Parameters:</p>
<ul>
<li><code>h</code> - 32-bit value in host order</li>
</ul>
<p>Return value: 32-bit value in network order</p>
<p>Usage example:</p>
<pre><code class="language-c">uint32_t val = mg_htonl(0x12345678);
</code></pre>
<h3 id="mg_crc32">mg_crc32()</h3>
<pre><code class="language-c">uint32_t mg_crc32(uint32_t crc, const char *buf, size_t len);
</code></pre>
<p>Calculate CRC32 checksum for a given buffer. An initial <code>crc</code> value should be <code>0</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>crc</code> - Initial CRC value</li>
<li><code>buf</code> - Data to calculate CRC32</li>
<li><code>len</code> - Data size</li>
</ul>
<p>Return value: Calculated CRC32 checksum</p>
<p>Usage example:</p>
<pre><code class="language-c">char data[] = &quot;hello&quot;;
uint32_t crc = mg_crc32(0, data, sizeof(data));
</code></pre>
<h3 id="mg_check_ip_acl">mg_check_ip_acl()</h3>
<pre><code class="language-c">int mg_check_ip_acl(struct mg_str acl, struct mg_addr *remote_ip);
</code></pre>
<p>Check IP address <code>remote_ip</code> against the IP ACL <code>acl</code>.</p>
<blockquote>
<p>Currently, only the IPv4 address format is supported for the ACL string.</p>
</blockquote>
<p>Parameters:</p>
<ul>
<li><code>acl</code> - an ACL string, e.g. <code>-0.0.0.0/0,+1.2.3.4</code></li>
<li><code>remote_ip</code> - an IP address</li>
</ul>
<p>Return value: 1 if <code>remote_ip</code> is allowed, 0 if not, and &lt;0 if <code>acl</code> is invalid</p>
<p>Usage example:</p>
<pre><code class="language-c">if (mg_check_ip_acl(mg_str(&quot;-0.0.0.0/0,+1.2.3.4&quot;), c-&gt;rem) != 1) {
  LOG(LL_INFO, (&quot;NOT ALLOWED!&quot;));
}
</code></pre>
<h3 id="mg_url_decode">mg_url_decode()</h3>
<pre><code class="language-c">int mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len, int form);
</code></pre>
<p>Decode URL-encoded string <code>s</code> and write it into <code>to</code> buffer.</p>
<p>Parameters:</p>
<ul>
<li><code>src</code> - String to decode</li>
<li><code>src_len</code> - Length of the string to decode</li>
<li><code>dst</code> - Pointer to output buffer</li>
<li><code>dst_len</code> - Output buffer size</li>
<li><code>form</code> - If non-zero, then <code>+</code> is decoded as whitespace.</li>
</ul>
<p>Return value: Decoded bytes count or negative value on error</p>
<p>Usage example:</p>
<pre><code class="language-c">char url[] = &quot;eexample.org%2Ftest&quot;;
char buf[1024];
mg_url_encode(url, sizeof(url) - 1, buf, sizeof(buf), 0); // buf is now &quot;example.org/test&quot;
</code></pre>
<h3 id="mg_url_encode">mg_url_encode</h3>
<pre><code class="language-c">size_t mg_url_encode(const char *s, size_t n, char *buf, size_t len);
</code></pre>
<p>Encode <code>s</code> string to URL-encoding and write encoded string into <code>buf</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>s</code> - String to encode</li>
<li><code>n</code> - String to encode length</li>
<li><code>buf</code> - Output buffer</li>
<li><code>len</code> - Output buffer size</li>
</ul>
<p>Return value: Number of characters written to <code>buf</code></p>
<p>Usage example:</p>
<pre><code class="language-c">char url[] = &quot;example.org/test&quot;;
char buf[1024];
mg_url_encode(url, sizeof(url) - 1, buf, sizeof(buf)); // buf is now &quot;example.org%2Ftest&quot;
</code></pre>
<h3 id="mg_print_base64">mg_print_base64</h3>
<pre><code class="language-c">size_t mg_print_base64(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print a buffer as a base64-encoded string. Expects data length and a pointer to the data as next arguments in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;hi, %m&quot;, mg_print_base64, 1, &quot;a&quot;);  // hi, &quot;YWJj&quot;
</code></pre>
<h3 id="mg_print_esc">mg_print_esc</h3>
<pre><code class="language-c">size_t mg_print_esc(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print a JSON-escaped string. Expects string length and a pointer to the string in the <em>va_list</em> <code>ap</code>. For null-terminated strings use <code>0</code> for string length, or the macro <code>MG_ESC()</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;{%m: %u}&quot;, MG_ESC(&quot;value&quot;), 123);           // {&quot;value&quot;: 123}
mg_snprintf(buf, sizeof(buf), &quot;{%m: %u}&quot;, mg_print_esc, 0, &quot;value&quot;, 123);  // {&quot;value&quot;: 123}
</code></pre>
<h3 id="mg_print_hex">mg_print_hex</h3>
<pre><code class="language-c">size_t mg_print_hex(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print a buffer as a hex-encoded string. Expects data length and a pointer to the data as next arguments in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;hi, %M&quot;, mg_print_hex, 1, 255);  // hi, ff
</code></pre>
<h3 id="mg_print_ip">mg_print_ip</h3>
<pre><code class="language-c">size_t mg_print_ip(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print an IP address using a specified character output function. Expects a pointer to a <code>struct mg_addr</code> as the next argument in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_addr addr;
addr.ip = MG_U32(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;);
mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_ip, &amp;addr);         // 97.98.99.100
</code></pre>
<h3 id="mg_print_ip_port">mg_print_ip_port</h3>
<pre><code class="language-c">size_t mg_print_ip_port(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print an IP address and port, using a specified character output function. Expects a pointer to a <code>struct mg_addr</code> as the next argument in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_addr addr;
addr.ip = MG_U32(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;);
addr.port = mg_htons(1234);
mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_ip_port, &amp;addr);         // 97.98.99.100:1234
</code></pre>
<h3 id="mg_print_ip4">mg_print_ip4</h3>
<pre><code class="language-c">size_t mg_print_ip4(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print an IP address using a specified character output function. Expects a pointer to a buffer containing the IPv4 address in network order as the next argument in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_ip4, &quot;abcd&quot;);         // 97.98.99.100
</code></pre>
<h3 id="mg_print_ip6">mg_print_ip6</h3>
<pre><code class="language-c">size_t mg_print_ip6(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print an IPv6 address using a specified character output function. Expects a pointer to a buffer containing the IPv6 address in network order as the next argument in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_ip6, &quot;abcdefghijklmnop&quot;);         // [4142:4344:4546:4748:494a:4b4c:4d4e:4f50]
</code></pre>
<h3 id="mg_print_mac">mg_print_mac</h3>
<pre><code class="language-c">size_t mg_print_mac(void (*out)(char, void *), void *param, va_list *ap);
</code></pre>
<p>Print a MAC address using a specified character output function. Expects a pointer to a buffer containing the hardware address as the next argument in the <em>va_list</em> <code>ap</code></p>
<p>Parameters:</p>
<ul>
<li><code>out</code> - function to be used for printing chars</li>
<li><code>param</code> - argument to be passed to <code>out</code></li>
</ul>
<p>Return value: Number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_snprintf(buf, sizeof(buf), &quot;%M&quot;, mg_print_mac, &quot;abcdef&quot;);          // 61:62:63:64:65:66
</code></pre>
<h2 id="io-buffers">IO Buffers</h2>
<p>IO buffer, described by the <code>struct mg_iobuf</code>, is a simple data structure
that inserts or deletes chunks of data at arbitrary offsets and grows/shrinks
automatically.</p>
<h3 id="struct-mg_iobuf">struct mg_iobuf</h3>
<pre><code class="language-c">struct mg_iobuf {
  unsigned char *buf;  // Pointer to stored data
  size_t size;         // Total size available
  size_t len;          // Current number of bytes
  size_t align;        // Alignment during allocation
};
</code></pre>
<p>Generic IO buffer. The <code>size</code> specifies an allocation size of the data pointed
by <code>buf</code>, and <code>len</code> specifies number of bytes currently stored.</p>
<img src="images/mg_iobuf.svg" alt="struct mg_iobuf diagram" />

<h3 id="mg_iobuf_init">mg_iobuf_init()</h3>
<pre><code class="language-c">int mg_iobuf_init(struct mg_iobuf *io, size_t size, size_t align);
</code></pre>
<p>Initialize IO buffer, allocate <code>size</code> bytes.</p>
<p>Parameters:</p>
<ul>
<li><code>io</code> - Pointer to <code>mg_iobuf</code> structure to initialize</li>
<li><code>size</code> - Amount of bytes to allocate</li>
<li><code>align</code> - Align <code>size</code> to the <code>align</code> mem boundary. <code>0</code> means no alignment</li>
</ul>
<p>Return value: 1 on success, 0 on allocation failure</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_iobuf io;
if (mg_iobuf_init(&amp;io, 0, 64)) {
  // io successfully initialized
}
</code></pre>
<h3 id="mg_iobuf_resize">mg_iobuf_resize()</h3>
<pre><code class="language-c">int mg_iobuf_resize(struct mg_iobuf *io, size_t size);
</code></pre>
<p>Resize IO buffer, set the new size to <code>size</code>. The <code>io-&gt;buf</code> pointer could
change after this, for example if the buffer grows. If <code>size</code> is 0, then the
<code>io-&gt;buf</code> is freed and set to NULL, and both <code>size</code> and <code>len</code> are set to 0.
The resulting <code>io-&gt;size</code> is always aligned to the <code>io-&gt;align</code> byte boundary;
therefore, to avoid memory fragmentation and frequent reallocations, set
<code>io-&gt;align</code> to a higher value.</p>
<p>Parameters:</p>
<ul>
<li><code>io</code> - iobuf to resize</li>
<li><code>size</code> - New size</li>
</ul>
<p>Return value: 1 on success, 0 on allocation failure</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_iobuf io;
mg_iobuf_init(&amp;io, 0, 10);  // An empty buffer with 10-byte alignment

if (mg_iobuf_resize(&amp;io, 1)) {
  // New io size is 10
}
</code></pre>
<h3 id="mg_iobuf_free">mg_iobuf_free()</h3>
<pre><code class="language-c">void mg_iobuf_free(struct mg_iobuf *io);
</code></pre>
<p>Free memory pointed by <code>io-&gt;buf</code> and set to NULL. Both <code>size</code> and <code>len</code> are set to 0.</p>
<p>Parameters:</p>
<ul>
<li><code>io</code> - iobuf to free</li>
</ul>
<p>Return value: None</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_iobuf io;
// IO buffer initialization
// ...

// Time to cleanup
mg_iobuf_free(&amp;io);
</code></pre>
<h3 id="mg_iobuf_add">mg_iobuf_add()</h3>
<pre><code class="language-c">size_t mg_iobuf_add(struct mg_iobuf *io, size_t offset, const void *buf, size_t len);
</code></pre>
<p>Insert data buffer <code>buf</code>, <code>len</code> at offset <code>offset</code>. The iobuf is expanded
if required. The resulting <code>io-&gt;size</code> is always aligned to the <code>io-&gt;align</code> byte boundary; therefore,
to avoid memory fragmentation and frequent reallocations, set <code>align</code> to a higher value.</p>
<p>Parameters:</p>
<ul>
<li><code>io</code> - iobuf to add data</li>
<li><code>offset</code> - Offset to add data</li>
<li><code>buf</code> - Data to add</li>
<li><code>len</code> - Data length</li>
</ul>
<p>Return value: new <code>io</code> length</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_iobuf io;         // Declare buffer
mg_iobuf_init(&amp;io, 0, 16);  // Initialise empty buffer with 16 byte alignment
</code></pre>
<img src="images/mg_iobuf_add1.svg" alt="Function mg_iobuf_init()" />

<pre><code class="language-c">mg_iobuf_add(&amp;io, io.len, &quot;hello&quot;, 5);  // Append &quot;hello&quot;
</code></pre>
<img src="images/mg_iobuf_add2.svg" alt="Function mg_iobuf_add()" />


<h3 id="mg_iobuf_del">mg_iobuf_del()</h3>
<pre><code class="language-c">size_t mg_iobuf_del(struct mg_iobuf *io, size_t offset, size_t len);
</code></pre>
<p>Delete <code>len</code> bytes starting from <code>offset</code>, and shift the remaining bytes.
If <code>len</code> is greater than <code>io-&gt;len</code>, nothing happens, so such call is silently ignored.</p>
<p>Parameters:</p>
<ul>
<li><code>io</code> - iobuf to delete data</li>
<li><code>offset</code> - Start offset</li>
<li><code>len</code> - Amount of bytes to delete</li>
</ul>
<p>Return value: New <code>io</code> length</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_iobuf io;
mg_iobuf_init(&amp;io, 0, 16);          // Empty buffer, 16-bytes aligned
mg_iobuf_add(&amp;io, 0, &quot;hello&quot;, 5);   // io-&gt;len is 5, io-&gt;size is 16
mg_iobuf_del(&amp;io, 1, 3);            // io-&gt;len is 2, io-&gt;size is still 16
</code></pre>
<img src="images/mg_iobuf_del.svg" alt="Function mg_iobuf_del()" />

<h2 id="queue">Queue</h2>
<p>Single-producer single-consumer non-blocking queue</p>
<h3 id="struct-mg_queue">struct mg_queue</h3>
<pre><code class="language-c">struct mg_queue {
  char *buf;
  size_t size;
  volatile size_t tail;
  volatile size_t head;
};
</code></pre>
<h3 id="mg_queue_init">mg_queue_init</h3>
<pre><code class="language-c">void mg_queue_init(struct mg_queue *q, char *buf, size_t size);
</code></pre>
<p>Initialize a queue</p>
<p>Parameters:</p>
<ul>
<li><code>q</code> - pointer to an <code>mg_queue</code> structure</li>
<li><code>size</code> - queue size in bytes</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_queue q;
char buf[100];
mg_queue_init(&amp;q, buf, sizeof(buf));
</code></pre>
<h3 id="mg_queue_book">mg_queue_book</h3>
<pre><code class="language-c">size_t mg_queue_book(struct mg_queue *q, char **ptr, size_t len);
</code></pre>
<p>Reserve space in a queue</p>
<p>Parameters:</p>
<ul>
<li><code>q</code> - pointer to an <code>mg_queue</code> structure</li>
<li><code>ptr</code> - pointer to where to store the address of the reserved space in the queue</li>
<li><code>len</code> - number of bytes requested</li>
</ul>
<p>Return value: number of bytes actually reserved</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_queue q;
char buf[100];
mg_queue_init(&amp;q, buf, sizeof(buf));
char *ptr;
if (mg_queue_book(&amp;q, &amp;ptr, len) &lt; len) {
  // Not enough space
} else {
  // Go ahead, memory area pointed to by ptr
}
</code></pre>
<h3 id="mg_queue_add">mg_queue_add</h3>
<pre><code class="language-c">void mg_queue_add(struct mg_queue *q, size_t len);
</code></pre>
<p>Add a new message to a queue</p>
<p>Parameters:</p>
<ul>
<li><code>q</code> - pointer to an <code>mg_queue</code> structure</li>
<li><code>len</code> - Data length</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_queue q;
char buf[100];
mg_queue_init(&amp;q, buf, sizeof(buf));
char *ptr;
if (mg_queue_book(&amp;q, &amp;ptr, len) &lt; len) {
  // Not enough space
} else {
  memcpy(ptr, my_data, len);  // Copy data to the queue
  mg_queue_add(&amp;q, len);      // Add a new message to the queue
}
</code></pre>
<h3 id="mg_queue_next">mg_queue_next</h3>
<pre><code class="language-c">size_t mg_queue_next(struct mg_queue *q, char **ptr);
</code></pre>
<p>Get the oldest message in a queue</p>
<p>Parameters:</p>
<ul>
<li><code>q</code> - pointer to an <code>mg_queue</code> structure</li>
<li><code>ptr</code> - pointer to where to store the address of the message in the queue</li>
</ul>
<p>Return value: number of bytes in message, 0 if no outstanding messages</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_queue q;
char buf[100];
mg_queue_init(&amp;q, buf, sizeof(buf));
...
char *ptr;
size_t len;
if ((len = mg_queue_next(&amp;q, &amp;ptr)) &gt; 0) {
  // message data pointed to by ptr
} else {
  // no messages
}
</code></pre>
<h3 id="mg_queue_del">mg_queue_del</h3>
<pre><code class="language-c">void mg_queue_del(struct mg_queue *q, size_t len);
</code></pre>
<p>Delete <code>len</code> bytes, oldest message in queue</p>
<p>Parameters:</p>
<ul>
<li><code>q</code> - pointer to an <code>mg_queue</code> structure</li>
<li><code>len</code> - number of bytes to delete</li>
</ul>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_queue q;
char buf[100];
mg_queue_init(&amp;q, buf, sizeof(buf));
...
char *ptr;
if ((len = mg_queue_next(&amp;q, &amp;ptr)) &gt; 0) {
  memcpy(somewhere, ptr, len);
  mg_queue_del(&amp;q, len);
} else {
  // no messages
}
</code></pre>
<h3 id="mg_queue_printf-mg_queue_vprintf">mg_queue_printf(), mg_queue_vprintf()</h3>
<pre><code class="language-c">size_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *);
size_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...);
</code></pre>
<p>Print message into a queue. Internally calls <a href="#mg_queue_book">mg_queue_book()</a> and <a href="#mg_queue_add">mg_queue_add()</a>, with the conveniency of printf.
The format string is evaluated first to calculate needed room and then again to actually print if there is available room in the queue; pay attention to side effects when calling.</p>
<p>Parameters:</p>
<ul>
<li><code>q</code> - pointer to an <code>mg_queue</code> structure</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: number of bytes printed</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_queue q;
char buf[100];
mg_queue_init(&amp;q, buf, sizeof(buf));
mg_queue_printf(&amp;q, &quot;hi&quot;);
</code></pre>
<h2 id="url">URL</h2>
<h3 id="mg_url_port">mg_url_port()</h3>
<pre><code class="language-c">unsigned short mg_url_port(const char *url);
</code></pre>
<p>Return port for given URL</p>
<p>Parameters:</p>
<ul>
<li><code>url</code> - URL to extract port</li>
</ul>
<p>Return value: Port for given URL or <code>0</code> if URL doesn&#39;t contain port and there
isn&#39;t default port for URL protocol</p>
<p>Usage example:</p>
<pre><code class="language-c">unsigned short port1 = mg_url_port(&quot;https://myhost.com&quot;) // port1 is now 443 (default https port)
unsigned short port2 = mg_url_port(&quot;127.0.0.1:567&quot;) // port2 is now 567
</code></pre>
<h3 id="mg_url_is_ssl">mg_url_is_ssl()</h3>
<pre><code class="language-c">int mg_url_is_ssl(const char *url);
</code></pre>
<p>Check if given URL uses an encrypted scheme</p>
<p>Parameters:</p>
<ul>
<li><code>url</code> - URL to check</li>
</ul>
<p>Return value: non-zero if given URL uses an encrypted scheme, zero otherwise</p>
<p>Usage example:</p>
<pre><code class="language-c">if (mg_url_is_ssl(&quot;https://example.org&quot;)) {
  // scheme is encrypted
}
</code></pre>
<h3 id="mg_url_host">mg_url_host()</h3>
<pre><code class="language-c">struct mg_str mg_url_host(const char *url);
</code></pre>
<p>Extract host name from given URL.</p>
<p>Parameters:</p>
<ul>
<li><code>url</code> - a URL string</li>
</ul>
<p>Return value: host name</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str a = mg_url_host(&quot;https://my.example.org:1234&quot;); // a == &quot;my.example.org&quot;
struct mg_str b = mg_url_host(&quot;tcp://[::1]&quot;); // b == &quot;[::1]&quot;
</code></pre>
<h3 id="mg_url_user">mg_url_user()</h3>
<pre><code class="language-c">struct mg_str mg_url_user(const char *url);
</code></pre>
<p>Extract user name from given URL.</p>
<p>Parameters:</p>
<ul>
<li><code>url</code> - URL to extract user name</li>
</ul>
<p>Return value: User name or empty string if not found</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str user_name = mg_url_user(&quot;https://user@password@my.example.org&quot;); // user_name is now &quot;user&quot;
</code></pre>
<h3 id="mg_url_pass">mg_url_pass()</h3>
<pre><code class="language-c">struct mg_str mg_url_pass(const char *url);
</code></pre>
<p>Extract password from given URL.</p>
<p>Parameters:</p>
<ul>
<li><code>url</code> - URL to extract password</li>
</ul>
<p>Return value: Password or empty string if not found</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str pwd = mg_url_user(&quot;https://user@password@my.example.org&quot;); // pwd is now &quot;password&quot;
</code></pre>
<h3 id="mg_url_uri">mg_url_uri()</h3>
<pre><code class="language-c">const char *mg_url_uri(const char *url);
</code></pre>
<p>Extract URI from given URL.
Note, that function returns a pointer within <code>url</code>; there is no need to free it explicitly</p>
<p>Parameters:</p>
<ul>
<li><code>url</code> - URL to extract URI</li>
</ul>
<p>Return value: URI or <code>\</code> if not found</p>
<p>Usage example:</p>
<pre><code class="language-c">const char *uri = mg_url_uri(&quot;https://example.org/subdir/subsubdir&quot;); // `uri` is now pointer to &quot;subdir/subsubdir&quot;
</code></pre>
<h2 id="logging">Logging</h2>
<p>Mongoose provides a set of functions and macros for logging. The application can
use these functions for its own purposes as well as the rest of Mongoose API.</p>
<h3 id="log">LOG()</h3>
<pre><code class="language-c">#define LOG(level, args)
#define MG_ERROR(args) MG_LOG(MG_LL_ERROR, args)
#define MG_INFO(args) MG_LOG(MG_LL_INFO, args)
#define MG_DEBUG(args) MG_LOG(MG_LL_DEBUG, args)
#define MG_VERBOSE(args) MG_LOG(MG_LL_VERBOSE, args)
</code></pre>
<p>Logging macros.
Usage example:</p>
<pre><code class="language-c">MG_INFO((&quot;Hello %s!&quot;, &quot;world&quot;));  // Output &quot;Hello, world&quot;
</code></pre>
<h3 id="mg_log_set">mg_log_set()</h3>
<pre><code class="language-c">void mg_log_set(const char *spec);
</code></pre>
<p>Set Mongoose logging level.</p>
<p>Parameters:</p>
<ul>
<li><code>spec</code> - String, containing log level, can be one of the following values:<ul>
<li><code>0</code> - Disable logging</li>
<li><code>1</code> - Log errors only</li>
<li><code>2</code> - Log errors and info messages</li>
<li><code>3</code> - Log errors, info and debug messages</li>
<li><code>4</code> - Log everything</li>
</ul>
</li>
</ul>
<p>Return value: None</p>
<p>It is possible to override log level per source file basis. For example, if
there is a file called <code>foo.c</code>, and you&#39;d like to set a global level to <code>2</code>
(info) but increase log level for file foo.c to <code>debug</code>, then, a <code>spec</code> should
look like <code>&quot;2,foo.c=3&quot;</code>. There could be several comma-separated overrides.</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_log_set(&quot;2&quot;);                  // Set log level to info
mg_log_set(&quot;2,foo.c=3,bar.c=0&quot;);  // Set log level to info, with overrides
</code></pre>
<h3 id="mg_hexdump">mg_hexdump()</h3>
<pre><code class="language-c">void mg_hexdump(const void *buf, int len);
</code></pre>
<p>Log a hex dump of binary data <code>buf</code>, <code>len</code>.</p>
<p>Parameters:</p>
<ul>
<li><code>buf</code> - Data pointer</li>
<li><code>len</code> - Data length</li>
</ul>
<p>Return value: none</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_hexdump(c-&gt;recv.buf, c-&gt;recv.len);  // Hex dump incoming data
</code></pre>
<h3 id="mg_log_set_fn">mg_log_set_fn()</h3>
<pre><code class="language-c">void mg_log_set_fn(mg_pfn_t logfunc, void *param);
</code></pre>
<p>Redirect logs to a custom function. Parameters:</p>
<ul>
<li><code>logfunc</code> - a pointer to a function that logs a single character</li>
<li><code>param</code> - a parameter for a logging function</li>
</ul>
<p>Usage example: redirecting logs to syslog.</p>
<pre><code class="language-c">static void mylog(char ch, void *param) {
  static char buf[256];
  static size_t len;
  buf[len++] = ch;
  if (ch == &#39;\n&#39; || len &gt;= sizeof(buf)) {
    syslog(LOG_INFO, &quot;%.*s&quot;, (int) len, buf); // Send logs
    len = 0;
  }
}
...
mg_log_set_fn(mylog, NULL);
</code></pre>
<h2 id="filesystem">Filesystem</h2>
<h3 id="struct-mg_fs">struct mg_fs</h3>
<pre><code class="language-c">struct mg_fs {
  int (*st)(const char *path, size_t *size, time_t *mtime);               // stat file
  void (*ls)(const char *path, void (*fn)(const char *, void *), void *); // List directory entries: call fn(file_name, fn_data) for each directory entry
  void *(*op)(const char *path, int flags);                               // Open file
  void (*cl)(void *fd);                                                   // Close file
  size_t (*rd)(void *fd, void *buf, size_t len);                          // Read file
  size_t (*wr)(void *fd, const void *buf, size_t len);                    // Write file
  size_t (*sk)(void *fd, size_t offset);                                  // Set file position
  bool (*mv)(const char *from, const char *to);                           // Rename file
  bool (*rm)(const char *path);                                           // Delete file
  bool (*mkd)(const char *path);                                          // Create directory
};

enum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };
</code></pre>
<p>Filesystem virtualisation layer.</p>
<p>Mongoose allows to override file IO operations in order to support different
storages, like programmable flash, no-filesystem devices etc.
In order to accomplish this, Mongoose provides a <code>struct mg_fs</code> API to
specify a custom filesystem. In addition to this, Mongoose provides several
built-in APIs - a standard POSIX, FatFS, and a &quot;packed FS&quot; API:</p>
<pre><code class="language-c">extern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek
extern struct mg_fs mg_fs_packed;  // Packed FS, see tutorials/core/embedded-filesystem
extern struct mg_fs mg_fs_fat;     // FAT FS
</code></pre>
<h3 id="struct-mg_fd">struct mg_fd</h3>
<pre><code class="language-c">struct mg_fd {
  void *fd;
  struct mg_fs *fs;
};
</code></pre>
<p>Opened file abstraction.</p>
<h3 id="mg_fs_open">mg_fs_open()</h3>
<pre><code class="language-c">struct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags);
</code></pre>
<p>Open a file in a given filesystem.</p>
<p>Parameters:</p>
<ul>
<li><code>fs</code> - a filesystem implementation</li>
<li><code>path</code> - a file path</li>
<li><code>flags</code> - desired flags, a combination of <code>MG_FS_READ</code> and <code>MG_FS_WRITE</code></li>
</ul>
<p>Return value: a non-NULL opened descriptor, or NULL on failure.</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_fd *fd = mg_fs_open(&amp;mg_fs_posix, &quot;/tmp/data.json&quot;, MG_FS_WRITE);
</code></pre>
<h3 id="mg_fs_close">mg_fs_close()</h3>
<pre><code class="language-c">void mg_fs_close(struct mg_fd *fd);
</code></pre>
<p>Close an opened file descriptor.</p>
<p>Parameters:</p>
<ul>
<li><code>fd</code> - an opened file descriptor</li>
</ul>
<p>Return value: none</p>
<h3 id="mg_file_read">mg_file_read()</h3>
<pre><code class="language-c">struct mg_str mg_file_read(struct mg_fs *fs, const char *path);
</code></pre>
<p>Read the whole file in memory. This allocates memory that must be freed by calling <code>mg_free</code></p>
<p>Parameters:</p>
<ul>
<li><code>fs</code> - a filesystem implementation</li>
<li><code>path</code> - a file path</li>
</ul>
<p>Return value: on success, the <code>struct mg_str</code> points to file data, which is guaranteed
to be nul-terminated, and its <code>len</code> field contains file length. On error, it contains a NULL pointer.</p>
<p>Usage example:</p>
<pre><code class="language-c">struct mg_str data = mg_file_read(&amp;mg_fs_packed, &quot;/data.json&quot;); // size = data.len
mg_free(data.buf);
</code></pre>
<h3 id="mg_file_write">mg_file_write()</h3>
<pre><code class="language-c">bool mg_file_write(struct mg_fs *fs, const char *path, const void *buf, size_t len);
</code></pre>
<p>Write a piece of data <code>buf</code>, <code>len</code> to a file <code>path</code>. If the file does not
exist, it gets created. The previous content, if any, is deleted.</p>
<p>Parameters:</p>
<ul>
<li><code>fs</code> - a filesystem implementation</li>
<li><code>path</code> - a file path</li>
<li><code>buf</code> - a pointer to data to be written</li>
<li><code>len</code> - data size</li>
</ul>
<p>Return value: true on success, false on error</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_file_write(&amp;mg_fs_fat, &quot;/test.txt&quot;, &quot;hi\n&quot;, 3);
</code></pre>
<h3 id="mg_file_printf">mg_file_printf()</h3>
<pre><code class="language-c">bool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...);
</code></pre>
<p>Write a printf-formatted data to a file <code>path</code>. If the file does not
exist, it gets created. The previous content, if any, is deleted.</p>
<p>Parameters:</p>
<ul>
<li><code>fs</code> - a filesystem implementation</li>
<li><code>path</code> - a file path</li>
<li><code>fmt</code> - format string in <code>printf</code> semantics. See <a href="#mg_snprintf-mg_vsnprintf">mg_snprintf</a>
for the list of supported format specifiers</li>
</ul>
<p>Return value: true on success, false on error</p>
<p>Usage example:</p>
<pre><code class="language-c">mg_file_printf(&amp;mg_fs_fat, &quot;/test.txt&quot;, &quot;%s\n&quot;, &quot;hi&quot;);
</code></pre>
<h3 id="mg_fs_ls">mg_fs_ls()</h3>
<pre><code class="language-c">bool mg_fs_ls(struct mg_fs *fs, const char *path, char *buf, size_t len);
</code></pre>
<p>Helper function to scan a filesystem in a sequential way, without using a callback function. Each call will return one entry until the list is exhausted</p>
<p>Parameters:</p>
<ul>
<li><code>fs</code> - a filesystem implementation</li>
<li><code>path</code> - a file path</li>
<li><code>buf</code> - a pointer to where to store the results</li>
<li><code>len</code> - buffer size</li>
</ul>
<p>Return value: true if there are more entries, need to call again; false when no more entries left.</p>
<p>Usage example:</p>
<pre><code class="language-c">  char buf[100] = &quot;&quot;;
  while (mg_fs_ls(&amp;mg_fs_posix, &quot;./&quot;, buf, sizeof(buf)))
    puts(buf);
</code></pre>


        <div class="position-sticky" style="bottom:5px;">
          <img src="images/arrow-up-circle-fill.svg"
               title="scroll to top"
               style="cursor:pointer; margin-left: 101%;"
               onclick="javascript:window.scrollTo(0, 0);"
               width="50" alt="arrow up" />
        </div>
      </div>

    </div>
  </div>

  <div class="bg-footer text-muted py-5">
    <div class="container">
        <div class="row">
            <div class="col-md-4">
                <div class="d-flex">
                    <img src="/images/logo.svg" height="50" width="50" class="my-auto" alt="Mongoose logo" />
                    <b class="my-auto mx-2 fs-4">Mongoose</b>
                </div>
                <div class="small my-3">Mongoose is an open source embedded HTTP/Websocket/MQTT library for C/C++</div>
                <div class="pb-3">
                    <a class="me-2 text-muted" href="https://www.facebook.com/Cesanta-457367447755484/timeline/">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16" role="img" aria-labelledby="Facebook page"><title id="Facebook">Facebook</title><desc id="page">Cesanta Facebook page</desc>
            <path d="M16 8.049c0-4.446-3.582-8.05-8-8.05C3.58 0-.002 3.603-.002 8.05c0 4.017 2.926 7.347 6.75 7.951v-5.625h-2.03V8.05H6.75V6.275c0-2.017 1.195-3.131 3.022-3.131.876 0 1.791.157 1.791.157v1.98h-1.009c-.993 0-1.303.621-1.303 1.258v1.51h2.218l-.354 2.326H9.25V16c3.824-.604 6.75-3.934 6.75-7.951z"/></svg>
                    </a>
                    <a class="me-2 text-muted" href="https://www.linkedin.com/company/cesanta-software"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16" role="img" aria-labelledby="Linkedin homepage"><title id="Linkedin">Linkedin</title><desc id="homepage">Cesanta Linkedin page</desc>
                      <path d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854V1.146zm4.943 12.248V6.169H2.542v7.225h2.401zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248-.822 0-1.359.54-1.359 1.248 0 .694.521 1.248 1.327 1.248h.016zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016a5.54 5.54 0 0 1 .016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225h2.4z"/>
                    </svg></a>
                    <a class="me-2 text-muted" href="https://twitter.com/CesantaHQ"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16" role="img" aria-labelledby="Twitter webpage"><title id="Twitter">Twitter</title><desc id="webpage">Cesanta Twitter page</desc>
                      <path d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z"/>
                    </svg></a>
                    <a class="me-2 text-muted" href="https://github.com/cesanta/mongoose"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16" role="img" aria-labelledby="Github landingpage"><title id="Github">Github</title><desc id="landingpage">Cesanta Github page</desc>
                      <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
                    </svg></a>
                    <a class="me-2 text-muted" href="https://www.youtube.com/@mongoose-networking-library/videos"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-youtube" viewBox="0 0 16 16">
                        <path d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.01 2.01 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.01 2.01 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31 31 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.01 2.01 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A100 100 0 0 1 7.858 2zM6.4 5.209v4.818l4.157-2.408z"/>
                      </svg></a>
                </div>
            </div>
            <div class="col-md-4 pb-2">
                <h2 class="fs-5">Quick Links</h2>
                <div><a href="/privacy/" class="text-muted">Privacy Policy</a></div>
                <div><a href="/documentation/" class="text-muted">Documentation</a></div>
                <div><a href="/licensing/" class="text-muted">Licensing</a></div>
            </div>
            <div class="col-md-4 text-right">
                <h2 class="fs-5">Contact</h2>
                <div class="text-muted d-flex"><svg class="my-auto me-2" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-house-door" viewBox="0 0 16 16">
                  <path d="M8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4.5a.5.5 0 0 0 .5-.5v-4h2v4a.5.5 0 0 0 .5.5H14a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146zM2.5 14V7.707l5.5-5.5 5.5 5.5V14H10v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v4H2.5z"/>
                </svg> Cesanta, 13 Edward Pl, Dublin 4, Ireland
                </div>
                <div class="text-muted d-flex"><svg class="my-auto me-2" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-telephone" viewBox="0 0 16 16">
                  <path d="M3.654 1.328a.678.678 0 0 0-1.015-.063L1.605 2.3c-.483.484-.661 1.169-.45 1.77a17.568 17.568 0 0 0 4.168 6.608 17.569 17.569 0 0 0 6.608 4.168c.601.211 1.286.033 1.77-.45l1.034-1.034a.678.678 0 0 0-.063-1.015l-2.307-1.794a.678.678 0 0 0-.58-.122l-2.19.547a1.745 1.745 0 0 1-1.657-.459L5.482 8.062a1.745 1.745 0 0 1-.46-1.657l.548-2.19a.678.678 0 0 0-.122-.58L3.654 1.328zM1.884.511a1.745 1.745 0 0 1 2.612.163L6.29 2.98c.329.423.445.974.315 1.494l-.547 2.19a.678.678 0 0 0 .178.643l2.457 2.457a.678.678 0 0 0 .644.178l2.189-.547a1.745 1.745 0 0 1 1.494.315l2.306 1.794c.829.645.905 1.87.163 2.611l-1.034 1.034c-.74.74-1.846 1.065-2.877.702a18.634 18.634 0 0 1-7.01-4.42 18.634 18.634 0 0 1-4.42-7.009c-.362-1.03-.037-2.137.703-2.877L1.885.511z"/>
                </svg> +353 1 592 5476</div>
                <div class="text-muted d-flex"><svg class="my-auto me-2" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-envelope" viewBox="0 0 16 16">
                  <path d="M0 4a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V4Zm2-1a1 1 0 0 0-1 1v.217l7 4.2 7-4.2V4a1 1 0 0 0-1-1H2Zm13 2.383-4.708 2.825L15 11.105V5.383Zm-.034 6.876-5.64-3.471L8 9.583l-1.326-.795-5.64 3.47A1 1 0 0 0 2 13h12a1 1 0 0 0 .966-.741ZM1 11.105l4.708-2.897L1 5.383v5.722Z"/>
                </svg> support@cesanta.com</div>
            </div>
        </div>
    </div>
</div>

<div id="tymodal" class="modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog  modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Thank you!</h2>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="content"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>


<script async defer src="https://www.googletagmanager.com/gtag/js?id=G-8XPJGJEQRP"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', 'G-8XPJGJEQRP');
    gtag('config', 'AW-620260907');
    gtag('consent', 'default', {
      'ad_personalization': 'denied',
      'ad_user_data': 'denied',
    });
</script>

<script src="https://analytics.ahrefs.com/analytics.js" data-key="NSpCBzb0aHnezfhzTT5eHg" async></script>


</body>
</html>
